
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>KIRAlzn夜神丶月</title>
	<meta name="author" content="KIRAlzn">

	
	<meta name="description" content="Compiler Perspective Oo Object Model Lession 2 compiler&rsquo;s perspective: 玩转oo对象模型(2) 之 不懂c怎么学c++ copyright: KIRAlzn 昨天去滑雪啊，真开心啊，感谢老天给了我一个聪明的大脑 &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="KIRAlzn夜神丶月" type="application/atom+xml">
	
	<link rel="canonical" href="KIRAlzn/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='http://www.gravatar.com/avatar/" + MD5("443681952@qq.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">KIRAlzn夜神丶月</a></h1>
<p class="subtitle">I wanna be the one you always can rely on.</p>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/KIRAlzn" title="Weibo">Weibo</a>
		
		
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
<hgroup>
  <h1><a href="/">KIRAlzn夜神丶月</a></h1>
  
    <h2>I wanna be the one you always can rely on.</h2>
  
</hgroup>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-01-11T00:00:00+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/01/11/compiler-perspective-oo-object-model-lession-2/" itemprop="url">Compiler Perspective Oo Object Model Lession 2</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>compiler&rsquo;s perspective:</h2>

<h2>玩转oo对象模型(2) 之 不懂c怎么学c++</h2>

<hr />

<p><strong>copyright: KIRAlzn</strong></p>

<hr />

<p>昨天去滑雪啊，真开心啊，感谢老天给了我一个聪明的大脑。。。2个小时就基本掌握要领，我能自由控制匀速下滑，自由刹车。。也没有人教，就是看别人滑自学的，还是挺开心的，唯一感觉内疚的就是，前2个小时太挫了，本想拉某人一把的可是自己又在半山腰的撒不住，后面会了，还想带某人一起滑的，但是我怎么找都找不到人了，然后就自己去下坡道happy去了。。。。。</p>

<hr />

<p>说句实话，为什么来百度实习，因为研一的时候，压力感觉很大，因为我们USTC的每一个同学实力都是不俗的。。。要想还是保持领先水平，不掉队，就必须比别人更努力。。。</p>

<p>当然以前学习是为了应付考试，所以现在学习，我最多的就是喜欢问自己为什么要这样？？
要从最根本的本质去理解事物，而不是被动的接受知识，然后背下来，不久就忘记了。。。。这样学了也是没用的。</p>

<p>多问自己几个为什么？</p>

<p>1.为什么要用最小二乘？？？而不用绝对值 or 最小4乘？</p>

<p>是误差项满足高斯分布的一个极大似然估计咯~~~</p>

<p>2.为什么计算机需要内存对齐？？
地址为什么不连续存放，要对齐，比如，按4的倍数存放？？
因为奇偶存储体的关系，内存可能有多个存储体，4的倍数机器，多半是4个存储体，一次启动访存，能读4个数据出来，否则读某些数据的时候，需要多次访存。。。。</p>

<p>3.。。。。。。</p>

<p>我写blog喜欢那种，渐入佳境的感觉，一步一步的走，不断的发起疑问，引起思考。</p>

<p>而且我自认为逻辑能力还是不错哒，最喜欢看推理片了。 - -</p>

<hr />

<p><strong>虽然现在已经没有那个动力了，谁来给我点动力？？？督促我一下，拜托。。。</strong></p>

<p><strong>好了，不扯淡了，开始写blog吧。。。</strong></p>

<hr />

<p>接上2篇，</p>

<p><strong>compiler&rsquo;s perspective:玩转oo对象模型(1) 之 初窥c++对象模型</strong></p>

<p><strong>编译器perspective &amp; 自然语言处理</strong></p>

<p>我在结尾埋了伏笔，说你要懂c，就你要懂以下这些，我今天来一步一步解释一下：</p>

<hr />

<p><strong>要思考，编译之后，生成怎么样的x86，calling convention，prolog/epilog，caller-saved/callee-saved register，堆栈平衡，所有变量的内存分布，函数符号修饰成什么样，静态链接，动态链接，地址修正，链接指示对编译过程的影响，如dllimport,dllexport,#pragma，函数声明等等</strong></p>

<hr />

<p><em>先随便写段c语言，现场翻一下c语言是什么??</em></p>

<p>void fun1(int a, int b)
{
    int temp = b;
    b = a;
    a = temp;   }</p>

<p>void fun2(int* a, int* b)
{
    int temp = *b;
    *b = *a;
    *a = temp; }</p>

<p>int fun3(int* pa, int* pb)
{
    int a = 3;
    char<em> b = &ldquo;409&rdquo;;
    int c = </em>pa + a + atoi(b);
    return c;
}</p>

<p>int main()
{</p>

<p>   int a = 1;</p>

<p>   int b = 2;</p>

<p>   fun1(a,b);</p>

<p>   fun2(&amp;a,&amp;b);</p>

<p>   printf(&ldquo;%d&rdquo;,fun3(&amp;a,&amp;b));</p>

<p>}</p>

<p>ok,以上是随手写的一段c程序，但是足以解释几个指标。</p>

<p>先用AT&amp;T演示一下：</p>

<p>.section    .rodata</p>

<p>.b:.string &ldquo;%d\n&rdquo;</p>

<p>.section    .text</p>

<p>fun1:
pushl %ebp <br/>
            movl  %esp,%ebp
pushl %ebxpushl %esi          <br/>
pushl %edipushl ecx</p>

<p>movl %ebx,12(%ebp)movl -16(%ebp),%ebx</p>

<p>movl %ebx,8(%ebp)</p>

<p>movl 12(%ebp),%ebx</p>

<p>movl -16(%ebp),%ebx</p>

<p>movl 8(%ebp),%ebx addl $4,%esppopl %edipopl %esipopl %ebxpopl %ebpret</p>

<h2>注：本次不讨论编译器优化算法，请参考上一篇</h2>

<p>ok,这段c语言程序，应该是大家大一的时候，写的第一个程序，但是真的懂了吗？</p>

<p>我们看fun1:</p>

<p>首先</p>

<p>1 . 为什么要</p>

<pre><code>        pushl %ebp               movl  %esp,%ebp
</code></pre>

<p>栈真是一个好东西，没有栈，计算机无法运行</p>

<p>a .栈可以支持function call中的所有过程，比如参数传递。。。</p>

<p>b .只要有个栈，可以随便起线程可以随便跑(为了验证我说的对不对，结尾我会放个程序)</p>

<p>。。。</p>

<p>因为这个栈如linux是在 0xc000 0000处，也就是3个G的地方，其实不准确，我们讨论这个3GB的时候是假定，我们只在虚拟内存下讨论，也就是说，屏蔽了os kernel的太多细节的情况下，假设 虚拟地址->物理地址</p>

<p>其实这个假设太不靠谱了，真是的情况是，(参考80386 reference manual)，作为写过os kernel的我，可以负责的告诉大家，(下次写一篇booting，即多核的机器启动过程)</p>

<p>Logical Address -> Lineal Address -> Physics Address</p>

<p>//    VM_USERHI,VM_STACKHI  &mdash;-> +==============================+ 0xf0000000</p>

<p>//    VM_STACKLO,      +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ 0xd0000000</p>

<p>//    VM_SCRATCHLO, -> +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ 0xc0000000</p>

<p>//    VM_FILELO, &mdash;-> +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ 0x80000000</p>

<p>//    VM_SHARELO, &mdash;> +==============================+ 0x40000000
//    VM_USERLO</p>

<p>无语啊，从pios os里面复制出来的代码格式在markdown里面全乱了，就这样吧，我偷懒了</p>

<p>看吧，VM_USERHI 和 VM_STACKHI是在3.75g的地方，也就是说最上面的虚拟内存只有256M，但是栈的位置不是准确的在 3GB下面一点点</p>

<p>扯远了，fun1的汇编代码是我手动反汇编的，基本和微软的cl.exe编译器相似，为什么这样写，当然是一个是想批评微软的编译器，另一个是为了说明问题，</p>

<p>栈为了支持过程调用，让不同function之间互相调用能通信，比如传一些参数，但是要知道，计算机里面没有什么高级的东西，我们只有，寄存器，内存，缓存，也就是说，只有线性地址的，东西能用，你只能用这些，像堆内存，指针，N级指针等东西，都是c给你抽象出来的，抽象程序再高一点c++ or java我就不说了。。。也就是说os kernel的开发人员，都是用裸内存的 ，你划一块这里说这里是栈，这里就是，你说这里是堆就是堆，你说这里是.data段，就是，你说是.bss就是。。。参考xv6和pios的裸内存分配算法。</p>

<p>在main函数中调用了fun1，fun1怎么和main函数进行通信？？</p>

<p>1 .fun1得传点东西给main  -> 参数（放到一个地方，等main去取）压栈</p>

<p>2 .fun1 和 main得遵守什么样的约定，不然fun1怎么知道你main压了几个参数？？？-> calling convention 和 从右向左压栈</p>

<p>3 . 对于fun1调用完成了，谁负责打扫后事？ 即压的多余的参数还在栈上，谁去清扫 -> calling convention</p>

<p>嗯，先驱者们设计了神奇的规则，
calling convention -> 有三种，1个是 __cdecl 1个是 __std 1个是fast call</p>

<p>为什么要搞出3个？当然是为了支持3种不同的情况：</p>

<p>先说__cdecl,其实真的大家耳熟能详了。。</p>

<p>int main(int argc,char** argv)</p>

<p>int main()
为什么有的时候这样带参数可以，有的时候不带参数也对？为什么编译器能让你过？</p>

<p>原因是main的调用规则是 __cdecl， (c的默认调用规则是__cdecl)</p>

<p>__cdecl念做 c call， 意思是由调用者(main)去负责清扫最后参数，(清扫:从栈上删去)</p>

<p>打个比方，这个比方很赞</p>

<p>int main()
{ <br/>
  int x;
  <strong>asm
  {
    mov eax, 9
    mov dword ptr [x], eax
  }
  printf(&ldquo;%d\n&rdquo;,x);
  </strong>asm
  {
    mov dword ptr [x], eax
  }
  printf(&ldquo;%d&rdquo;,x);
  return 0;
}</p>

<p>为什么2次输出的eax值不一样呢，那次上课(计算机病毒与免疫系统)，不用多说，以我犀利的目光第一个举手抢答，然后加上了宝贵的课堂分数，当然和最后的期末98分，离不开关系。。我又催牛逼了。哈</p>

<p>我就不卖关子了，因为</p>

<p>caller-saved 寄存器是 eax,ecx,edx    调用者保存寄存器</p>

<p>callee-saved 寄存器是 ebx,esi,edi    被调用者保存寄存器</p>

<p>ps:有些人把ebp和esp归为callee-saved寄存器，不知道是什么心态。。动一下值，编译都不过的。。</p>

<p>eax作为caller-saved寄存器，是由调用方，也就是main函数来负责保证它的值不被改变，so，换句话说，printf这个函数是被调用方，也就是说，不负责保存caller_saved寄存器，被调用方，只负责保存callee-saved寄存器</p>

<p>ok，可能大家有点晕，没事，我再说清楚点</p>

<p>在本例中，main是调用者，printf是被调用者，so，main得负责eax,ecx,edx的值不变(不变的意思是main必须得保证，在main中调用别的函数返回以后，eax的值不变，但是也可以不保护，除非你在main里面没有用到eax保存任何中间结果)
那printf负责保护 ebx,esi,edi的值不变，换句话说，printf不负责保护eax的值，</p>

<p>so，原因很明显，调用printf以后，在printf中<strong>可能</strong>改变了eax的值，所以2次main的eax值，可能不一样。</p>

<p>so,如果eax保存的重要的中间值，应该怎么办的呢，说好的main要保护 eax,ecx,edx呢？？</p>

<h3>main说，eax，我要保护你，怎么能让你受伤害呢？</h3>

<p>main说，我只能这样了：</p>

<p>push eax</p>

<p>printf()</p>

<p>pop eax</p>

<h3>ok，交代了 caller-saved寄存器 和 callee-saved 寄存器，我也松了口气 ，继续深入。</h3>

<hr />

<p>main的汇编我还没写，补上，<em>(原谅我用intel语法简化，也就说有的是AT&amp;T语法，有但是intel汇编，只为说明问题，不要纠结)</em></p>

<p>.globl mainmain:
push dword ptr [b]
push dword ptr [a]
call fun1
add 8,esp  <br/>
(我们假设在32位系统下，int占4个byte，64位下其实int也占4个byte，但是long占8个，指针占8个，不能和int通用，所以写程序用long代替int是最好的了，移植到64位下不用改)</p>

<p>好的，
很明显</p>

<p>1 .参数从右向左压栈，为什么从右向左，不要问我为什么，先驱约定的，注意我用词，是约定，你也可以约定从左往右，没问题，只要修改下编译器即可，这个是约定，作为写过编译器的人们，大家心里很明了</p>

<p>2 .call 完 fun1之后，为什么要 add 8，esp？？？？</p>

<p>这个是重中之重，这个就是 __cdecl 的来源，由调用者（main）清扫参数，
b</p>

<p>a</p>

<p>return address</p>

<p>|ebp</p>

<p>|caller-saved register</p>

<p>|&hellip;</p>

<p>调用玩fun1之后，fun1的 running stack，又叫做 call stack 被销毁，return address被弹出</p>

<p>只剩下</p>

<p>b</p>

<p>a</p>

<p>所以在 __cdecl中很明显，是由main去 add 8，esp，去把这2个参数，从栈上清扫掉。</p>

<p>ok，了解了 __cdecl， __stdcall 很明显了，是由被调用者， fun1去清扫参数</p>

<p>即用 ret n指令，即在fun1的结尾处，用 ret 8指令，扫完参数，再回到main函数</p>

<hr />

<p><strong>这是2种完全不同的调用约定，</strong></p>

<p><strong>注意，我反复强调，这是约定，约定。你可以任意去改，只要合理，只是现在的编译器都写好了，你不好改了，但是我们可以自己开发编译器，这不是一个很大的问题。</strong></p>

<hr />

<p>ok，剩下fast call也很容易了，大家肯定发现一个问题，寄存器通常比内存要快，so，用寄存器去传参数不是更快吗？对的，fast call便是解决这个问题，缺点是解决的不彻底。</p>

<p>由ecx，edx作为参数约定，缺点太明显了，只能有2个参数，多一个不行。。。。坑吧。。。所以之所以成为fast call也有一层含义像是快餐一样，很少吃。</p>

<h3>好的，说完fast call，我终于可以说 64位下的汇编了</h3>

<p>64位下没记错应该有15个寄存器，多了好多个，一个是用来支持寄存器分配算法，另一个就是用来作为参数传递的，呵呵，<strong>把fast call的2个改为6个</strong>。。。</p>

<p>明白了吧~~~~~~~</p>

<hr />

<h3>ok，继续深入，说完了calling convention，继续说说这段汇编</h3>

<h3>考虑编译器优化算法，寄存器分配(图着色)</h3>

<p>经过这个算法之后，算出live-out，不同的函数，<strong>在同一个时刻</strong>用到的寄存器的个数，32位系统下不一定正好是3个，so不一定一进函数就立刻保存这3个寄存器。。。考虑下 .text段代码爆棚的感受。。
            pushl %ebp               movl  %esp,%ebp            pushl %ebx            pushl %esi            pushl %edi
我记得我以前吐槽过微软的编译器，肯定没有经过寄存器分配的算法。。。搞毛线啊。。比gcc差远了，不知道现在vs2013改进了没有。。。
经过寄存器分配算法之后，不需要用那么多的寄存器，保存起来，除了占 .text的空间，还能干什么？</p>

<h2>当然 pushl %ecx是值得表扬的，以前说过，同样是开辟4个字节，pushl %ecx比 sub $4,%esp拥有更少的字节数。</h2>

<p>关于 prolog/epilog
查下英文单词的意思，也是很明显的，就是说，开场白/收场白</p>

<p>也就是进入.text段的时候，这个函数标号所在地址的，函数汇编代码的起始部分 和 结束部分</p>

<p>.text
我们从os kernel角度分析一下，.text段在哪里，首先在 机器启动的开始部分，还没有打开分页，也就是说 CRO寄存器的PG位没有打开的时候，linear地址->就是物理地址，</p>

<h4>也就说，此时不走页表so，在 kernel.img 里面，肯定不能把kernel的代码烧在很高的地址，虽然虚拟地址有4G（32bit），因为虚拟内存4G，但是物理内存只有1GB，你os不是照样运行的好好的吗？就是这个原因，最初的.text 和 .data ，还有 .rodata .bss .directive(这是全拼) 等等段，都是在1M-4M之前，也就是在pios os kernel保证代码和数据在3M以内，等到 os kernel 加载完毕的时候，各个部件初始化完毕的时候会</h4>

<p>call main
这个main是内核编译到高地址，如windows是编译到0x80000000这里，linux是0xc0000000</p>

<h4>之后都是走页表，把高的虚拟地址，映射到物理地址打住，此时不是在讨论os kernelok，.text段里面有很多代码，是代码段，整个编译器编译的代码都在 .text段</h4>

<p>so，你这个fun1也在代码段是吧。fun1其实只是一个标号，代表着一个地址，也就是 fun1 的代码在哪里，ok，进入代码的时候，你需要在</p>

<h4>内存栈(又称为硬件栈)，上弄一块自己的地盘，就是所谓的 call stack frame，栈桢</h4>

<p>通过 不断压入ebp，形成一个硬件的链表，
在制作游戏外挂的时候，可以截获任意一个栈桢，截获其返回地址，然后就可以干坏事了。。
so，反外挂怎么样检测？？？？
只有扫 ebp链 了，但是扫 ebp链真的有用吗？ 明显是不行的，因为有隐藏栈桢技术，我以前写过完整代码，有兴趣的同学可以私密我。
so，prolog/epilog 就是在栈上划分一块地盘用的，给某个函数用， 栈桢头/栈桢尾&mdash;&mdash;&mdash;-</p>

<h4>关于 函数符号修饰成什么样？</h4>

<p>不需要太深入了解了，不搞信息安全的基本不需要知道，我就简单说下以fun为例：
__cdecl     : <em>fun
__stdcall:    </em>fun@8
__fastcall:   @fun@8<strong>知道这个有什么用呢？</strong>
#pragma的时候有用，假设是 std call你写 #pragma comment(linker, &ldquo;/EXPORT:_fun@8&rdquo;)，</p>

<h4>在双引号里面必须得是 编译器修饰过的 名字，因为这个是给链接器看的。</h4>

<p>有兴趣的我可以写在下一篇blog里面。&mdash;&mdash;&mdash;-</p>

<h4>关于 静态链接，动态链接，地址修正，链接指示对编译过程的影响，如dllimport,dllexport,#pragma，函数声明 感觉要写个1w字才罢休啊。。放在下一篇吧。</h4>

<hr />

<h4>关于所有变量的内存分布，有了这个概念，反汇编起来真是easy</h4>

<p>为什么我能轻易反汇编？
void fun1(int a, int b)</p>

<p>{
    int temp = b;
    b = a;
    a = temp;   }</p>

<p>int x = 3;</p>

<p>int v;</p>

<p>main()</p>

<p>{
  int a = 1;
  int b = 2;
  fun1(a,b);
}ok,我就详细解释一遍，看下 fun1的栈桢
b
a
return address
|ebp          &lt;-ebp寄存器指向（前面加上了 <strong>|</strong>  表示是fun1的栈桢区域，没有别的意思）
|ebx
|esi
|edi
|temp
|&hellip;. 编译器算法计算local variables占多少个字节之后，sub 减去一段空间来放置，然后就是多加一些空间支持
|&hellip;.过程调用，我从 CSAPP里面学的，这样在编译器生成自我调用的汇编代码的时候很方便，栈桢不会crash
很明显，
return address 在 ebp+4的位置a 在 ebp+8 的位置
b 在 ebp+12的位置
接下里就是 callee-saved寄存器，假设没经过寄存器分配(图着色)算法的优化，则保存全部的callee-saved寄存器
temp -> local variable 在 ebp-16 的位置</p>

<p>int x = 3;</p>

<p>int v;
对于已经初始化了的全局变量和局部静态变量，如x，是放在 .data 段
对于没有初始化的全局变量和局部静态变量，如v，是放在 .bss 段.bss以上是pios kernel裸内存分配算法的关键好了，找到全部变量的位置，反汇编还不容易吗？？</p>

<h4>顺便提一句，对于x86，同是内存操作对于mov指令是不行的，需要经过寄存器转换。</h4>

<hr />

<h1>关于fun1的语义</h1>

<p><strong>以前大一的时候，老师都教说，哦，fun1这里a，b是形参，他们交换是不改变调用时候的a，b的值的，
高级一点的老师会说，哦，这里是 pass by value，所以在fun1形参的时候是副本</strong></p>

<h1>听起来好像很有道理，其实都是扯淡，怎么能说服自己？</h1>

<p>拿事实说话，所谓的pass by value，传的是副本，话是没错啦，其实比如 a=1 b=2，就把它的值copy一份，压到栈上，然后给他们起个名字，再叫做a，b，其实没用，a和b指向的地址根本变的一塌糊涂了，都是指在fun1栈桢里面的位置了，再也不是main栈桢里面的的那两个地址了。</p>

<p>a 在 ebp+8 的位置
b 在 ebp+12的位置</p>

<p>所以你再在fun1的栈桢里面做什么小动作，main栈桢里面的a，b值能变吗？？？
这个就是所谓的 pass by value</p>

<p>pass by reference 呢？</p>

<h2>栈上放的是指针呦，直接去访存了，访问main的栈桢里面的位置了。。。当然会变了。。。。。。。</h2>

<h4>关于返回值</h4>

<p>返回值，约定，放到 eax里面，这就是为什么c语言中，返回值只能是一个值，你要是想反回多个值，只能创建一块内存，然后往里面塞，然后返回这块内存的地址</p>

<hr />

<h4>关于指针， inline函数</h4>

<p>说道指针，不得不提一下  inline 函数，记得有些书本里面把inline函数，翻译成 <strong>在线函数</strong>，也不知道翻译者的心态是神马。。。。。。。所谓inline就是一些小的函数，编译的时候，把代码直接编译过来，省去的函数调用的开销。</p>

<h4>能省去多少开销？？</h4>

<p>csapp里面说的很清楚，一般 函数调用需要 10 - 12个 cpu的cycle，时钟周期。
所以如果代码量很小的情况下，小于10个时钟周期，<strong>那就是赚了？？</strong></p>

<h4>真的赚了吗？？</h4>

<p>不一定的，如果函数调用太频繁了，也不需要统计学的博士来告诉你，代码段会爆棚吧，相当于一个宏了，编译器，见到函数调用的地方，就给变成代码替换，调用100w次，就替换100w次，会爆棚吧？？</p>

<h4>神马情况下编译器不接受inline申请？？</h4>

<p>你在函数前面写个inline，只是向编译器申请，意思是大哥，这个我想inline，你看行不行？？</p>

<h4>编译器有权利拒绝你的申请，</h4>

<p>编译器会说，哥用算法看下你到底小不小，到底和函数调用比起来，10个cpu时钟周期到底该不该剩下来？？？
神马情况下会拒绝？？？
2种情况：
1 .用函数指针调用的时候 -> 你都用函数指针调用了，说明你函数体必须存在于内存中，得有指针指向它，不然怎么调用？</p>

<h2>2 .多态 -> 同函数指针</h2>

<h4>关于c语言的异常， 穷人异常: setjump longjump</h4>

<p>setjump相当于给当时的栈桢给一个快照，咔嚓，一声，把此时的栈桢给照下来，下次longjump的时候直接返回回来，
当然我们做编译器的时候有2种，一个是异常栈，一个是异常表，两种实现方式，
异常栈 -> 每次try都会压一个frame，嵌套异常就能直接返回到上一个frame的位置，优点是，当发生异常的时候，返回速度巨快，缺点很明显，代码不是全速运行，每到一个try，都要压一个frame</p>

<h4>so，基于以上原因，adobe公司，10年禁止使用异常也不是不无道理</h4>

<h2>异常表 -> 哇，好牛逼的东西，如果代码不发生异常，代码是全速运行，叫做pay as u go，你出错了，我才惩罚你，才要钱，缺点也很明显，就是如果真的发生异常了，那就需要  unwind frame了。。。。注意我的用词 unwind，很慢，很慢。。</h2>

<h4>ok，撤了这么久的c语言，来深究一下c++吧，我好累。</h4>

<p>上面的代码我埋了一个很深的伏笔，可能读者已经发现了，我写了 fun1,fun2,fun3这种 ugly的名字，没有办法，c语言就是这样，同一类的函数，必须取不同的名字，当然你可以优化下名字之类的，
<strong>但是，c++看到了这个缺点：</strong>
引入<strong>函数重载</strong>去解决这个问题
更进一步的，既然要解决这种ugly的命名问题，
<strong>c++又引入：</strong>函数<strong>形参默认值，模板，命名空间</strong>去更进一步解决。</p>

<p>命名空间:让第三方的库也可以多取一些名字，比如你的库里有max，我就不能取了？？？负责同一个名字，编译器是编译不过的。
其他两个同理。</p>

<h4>都是为了让函数的名字尽量变少####为什么要让函数的名字变少，除了命名起来的ugly的原因，还有什么？？？？</h4>

<p>那就是在很久以前，c的库都已经写好了，比如微软的 printf malloc calloc &hellip;
(####这里涉及到动态链接的知识，太复杂，一时半会说不清楚，下次吧)
然后你的代码里是需要调用 printf的吧？还有很多其他函数？命名是有冲突的吧？？</p>

<h4>所以其根本原因是什么呢？？？就是减少已经编译好的模块obj中的命名冲突!!!!!为什么？？因为已经写好的库太多了，里面的函数名字，都在符号表里面，意味着，已经申请过了，你不能再用，你要是再用，编译器就编译不过了。。。明白了吗</h4>

<p>&mdash;&mdash;&mdash;-####好的，其实接上面，还有多态，有异曲同工之妙
void fun(BASE* b);
一个base的指针作为参数，可以接受其所有子孙儿女的对象指针，意味着又简化了代码不是吗，否则，传不同的指针，又需要多写几个函数？？？
&mdash;&mdash;&mdash;-#### ok,看下编程语言的演化过程
汇编->c->c++->java 其他语言不考虑。
当初老外用汇编写代码的时候，因为那个时候内存也小，所以写代码特别注重省内存和效率，后来老外们发现，用汇编语言写代码太费劲了。尤其是写大型的软件
第一版本的unix是用汇编写的，坑的要死啊，每天改bug的速度==引进新bug的数目。。。。。
所以老外发明了c语言，因为c是对x86的浅封装，写一条c能少写几条汇编，因为从汇编开始写代码的人，都心里无比知道内存分配，知道写一条c，对应哪些汇编。</p>

<h4>这个过程就是所谓的抽象人们当时把c称作高级语言。。。。。</h4>

<p>后来为什么引进c++？一个是为了解决c的某些坑，一个是c++抽象的思想，让人写代码的时候更注重人的抽象，写出来的代码能更让人看懂，至于计算机能不能看懂，交给编译器去解决。
面向对象的好处还有就是 用了设计模式之后，对代码的可维护性，扩展性，灵活性有了很大的提升</p>

<h1>因为需求总是在变的，作为coder要知道，我让你变，你变了之后，哥的代码就只变一点点，你以为会让我推翻重写吗？？太天真了。</h1>

<h2>&mdash;&mdash;&mdash;-#好了，我累死了。。。关于c c++ java 的演化过程，就下次再写吧。。。</h2>

<p>结尾还是要点金一下哒。。。我上病毒课以前写的一段程序送给大家。。。
能完全完全看懂这个，基本干信息安全没问题了</p>

<h2>以下代码是两个函数在 .text段来回迭代，然后计算fibnaci序列的代码</h2>

<p>#include &lt;stdio.h></p>

<p>int count;</p>

<p>struct ctx
{
  int eip, esp, ebx, ebp, v;
} M, A, B;</p>

<p><strong>declspec(naked) void swtch(struct ctx *from, struct ctx *to)
{
    </strong>asm{</p>

<pre><code>    mov eax, [esp+4]
    pop dword ptr [eax]
    mov [eax+4], esp
    mov [eax+8], ebx
    mov [eax+12], ebp

    mov ecx, [esp+4]
    mov ebp, [ecx+12]
    mov ebx, [ecx+8]
    mov esp, [ecx+4]

    push [ecx]
    ret
}
</code></pre>

<p>}</p>

<p>void A_proc()
{</p>

<p>__asm
{</p>

<p>fibloop1:
    cmp dword ptr [count],1
    je next1</p>

<pre><code>dec dword ptr [count]

mov esi,dword ptr [B+16]    
add dword ptr [A+16],esi

lea esi,dword ptr [B]
push esi
lea esi,dword ptr [A]
push esi
call swtch
jmp fibloop1
</code></pre>

<p>next1:
    mov edi,dword ptr [B+16]
    lea esi,dword ptr [M]
    push esi
    lea esi,dword ptr [A]
    push esi
    call swtch</p>

<p>}</p>

<p>}
void B_proc()
{</p>

<p>__asm{</p>

<p>fibloop2:
    cmp dword ptr [count],1
    je next2</p>

<pre><code>dec dword ptr [count]

mov esi,dword ptr [A+16]   
add dword ptr [B+16],esi


lea esi,dword ptr [A]
push esi
lea esi,dword ptr [B]
push esi
call swtch

jmp fibloop2
</code></pre>

<p>next2:
    mov edi,dword ptr [A+16]</p>

<pre><code>lea esi,dword ptr [M]
push esi
lea esi,dword ptr [B]
push esi
call swtch
</code></pre>

<p>}</p>

<p>}</p>

<p>int main(int argc,char** argv)
{
  int Astack[1024];
  int Bstack[1024];
  int result;</p>

<p>  A.eip = (int)A_proc;
  A.esp = (int)(&amp;Astack[1023]);
  B.eip = (int)B_proc;
  B.esp = (int)(&amp;Bstack[1023]);</p>

<p>  A.v = 1;
  B.v = 1;</p>

<p>   if(argc &lt;= 1)
   {
       printf(&ldquo;please input one command line parameter(number&lt;40)&rdquo;);
       return -1;
   }</p>

<p>  count= atoi(argv[1]);</p>

<p>  if(count == 0)
  {<br/>
      printf(&ldquo;fib(%d) = 0\n&rdquo;,atoi(argv[1]));
      return 0;
  }
  swtch(&amp;M, &amp;A);</p>

<p>  __asm{
      mov dword ptr [result],edi</p>

<p>  }</p>

<p>  printf(&ldquo;fib(%d) = %d\n&rdquo;,atoi(argv[1]),result);</p>

<p>  return 0;
}</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-25T20:44:53+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/08/25/think-python-fetch-openssl-output-string/" itemprop="url">Think Python Fetch Openssl Output String</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>think python:fetch openssl&rsquo;s string output</h2>

<hr />

<p><strong>copyright: KIRAlzn</strong></p>

<p><strong>自我介绍: USTC研一学生，目前在intel pccg department实习，研发岗</strong></p>

<hr />

<p>老大说无线充电中ptu和pru通信的固件不安全，所以要加上RSA加密，但是有以下不好办的地方：</p>

<hr />

<p><strong>1.由于公钥和私钥都是很长，比如512，1024，1280，1536，2048等等，这么长的数据是不能放到long等辈之中的，得考虑类似unsigned char(byte)数组，大整数乘方仍然是加密算法的难点之一</strong></p>

<p><strong>2.openssl命令输出返回整个字符串，里面有各式各样的数据，不要好fetch出你想要的，而且随着RSA长度的递增，公钥和私钥输出不止一行(每行15个byte)，当然可以根据长度计算，但是很麻烦不是吗？</strong></p>

<p><strong>3.openssl命令输出的公钥和私钥，第一个(little ending) byte，比如 0xab , openssl就会自动多加上一个 0x00 去间隔，所以整个密钥有的时候会多出一个？怎么处理？</strong></p>

<p><strong>4.最蛋疼的是openssl输出的字节序 和 RSA处理的字节序是反的，得反转，怎么破？首先openssl输出的每个字节是不带0x的，而且是逆序，手动去处理会疯掉的</strong></p>

<hr />

<p>ok，这些问题也不是什么难事，用脚本语言可以很简单的解决，要不然脚本语言就没有存储在的必要了。
最后附录上全部30几行代码，可以直接使用哦，以后用openssl取非常大的公钥和私钥再也不要手动咯~~~</p>

<hr />

<p>为什么不手动去处理，看下openssl的输出就秒懂了&hellip;&hellip;&hellip;</p>

<p><strong>C:\Users\lzn\Desktop>python try.py 512</strong>   这个是我写的try.py，512是RSA长度，命令行参数</p>

<p>Private-Key: (512 bit)</p>

<p>modulus:</p>

<pre><code>00:be:30:36:c1:63:35:a2:02:dd:f8:83:86:f5:e4:
ef:a2:75:9f:02:56:94:ba:a5:dc:76:59:1b:b6:4c:
3e:80:1b:10:c0:c6:d4:8f:0d:85:1c:81:25:21:5d:
19:56:bd:f3:74:17:a4:5e:80:50:11:cb:2d:7d:ab:
73:8b:44:26:37
</code></pre>

<p>publicExponent: 65537 (0x10001)</p>

<p>privateExponent:</p>

<pre><code>00:a9:7f:fe:cc:cb:c6:78:e5:65:3e:9e:ba:21:5c:
2f:d5:f2:4e:0c:9f:6d:5e:0b:84:38:55:a2:45:0e:
1e:85:bc:0d:d8:17:ab:17:8a:8e:e9:57:1d:91:ce:
3b:39:0e:4b:1f:6d:a6:e4:1c:7d:2d:a9:d1:ec:46:
87:11:bc:e3:c1
</code></pre>

<p>prime1:</p>

<pre><code>00:f5:9e:94:d3:2c:f8:05:ac:f6:93:22:df:e3:63:
0a:d7:7f:e8:bd:b8:59:bd:81:9b:75:17:48:48:c1:
50:54:33
</code></pre>

<p>prime2:</p>

<pre><code>00:c6:39:e8:c7:49:3b:ef:33:a0:47:8c:c2:ca:46:
44:9a:ed:f0:3f:e0:de:17:18:33:ee:05:4b:46:2c:
26:01:ed
</code></pre>

<p>exponent1:</p>

<pre><code>00:b0:c3:d0:fd:6d:a6:8d:87:1d:e9:64:36:d6:91:
87:d2:f1:75:d1:5b:e4:11:b3:3d:ea:f5:b7:8a:cc:
bc:ff:eb
</code></pre>

<p>exponent2:</p>

<pre><code>29:df:89:c0:af:43:ad:df:e5:f7:b7:50:5e:92:41:
63:c8:e7:7b:56:f1:13:47:d5:90:6e:25:dc:88:ee:
ee:71
</code></pre>

<p>coefficient:</p>

<pre><code>24:a6:f6:eb:d8:ce:5b:80:9d:ac:09:10:7b:b9:ad:
65:98:1c:29:ac:3f:ee:9b:6f:76:c3:e7:7a:02:a6:
fa:a1
</code></pre>

<p><strong>//上面是openssl输出的字符串</strong></p>

<p><strong>//下面是经过我处理后的结果，可以直接粘贴到RSA算法里面，省去了不少时间</strong></p>

<p>modulus:</p>

<p>0x37,0x26,0x44,0x8b,0x73,0xab,0x7d,0x2d,0xcb,0x11,0x50,0x80,0x5e,0xa4,0x17,0x74,
0xf3,0xbd,0x56,0x19,0x5d,0x21,0x25,0x81,0x1c,0x85,0x0d,0x8f,0xd4,0xc6,0xc0,0x10,
0x1b,0x80,0x3e,0x4c,0xb6,0x1b,0x59,0x76,0xdc,0xa5,0xba,0x94,0x56,0x02,0x9f,0x75,
0xa2,0xef,0xe4,0xf5,0x86,0x83,0xf8,0xdd,0x02,0xa2,0x35,0x63,0xc1,0x36,0x30,0xbe,</p>

<p>privateExponent:</p>

<p>0xc1,0xe3,0xbc,0x11,0x87,0x46,0xec,0xd1,0xa9,0x2d,0x7d,0x1c,0xe4,0xa6,0x6d,0x1f,
0x4b,0x0e,0x39,0x3b,0xce,0x91,0x1d,0x57,0xe9,0x8e,0x8a,0x17,0xab,0x17,0xd8,0x0d,
0xbc,0x85,0x1e,0x0e,0x45,0xa2,0x55,0x38,0x84,0x0b,0x5e,0x6d,0x9f,0x0c,0x4e,0xf2,
0xd5,0x2f,0x5c,0x21,0xba,0x9e,0x3e,0x65,0xe5,0x78,0xc6,0xcb,0xcc,0xfe,0x7f,0xa9,</p>

<p><strong>处理完之后，可以直接生成任意长度的公钥和私钥，然后直接粘贴到byte数组里面，感觉省去了非常多繁琐的工作量，可以让计算机去做的为啥不让计算机去做呐？</strong></p>

<hr />

<p><strong>当然，短短的30几行python我就搞定了，how to think python ？</strong></p>

<hr />

<p>考虑:
1.考虑如下片段，如果要取出中间这东东，难点我上面已经总结了。
a. 粗体00是多出来的，因为little ending结尾是字母
b. 输出有很多行，如果是一行一行的fetch，虽然行数是能够算出来的，但是还是要拼接，非常麻烦
c. 反转所有字节序
d. &hellip;&hellip;</p>

<p><strong>modulus:</strong>
    <strong>00</strong>:be:30:36:c1:63:35:a2:02:dd:f8:83:86:f5:e4:
    ef:a2:75:9f:02:56:94:ba:a5:dc:76:59:1b:b6:4c:
    3e:80:1b:10:c0:c6:d4:8f:0d:85:1c:81:25:21:5d:
    19:56:bd:f3:74:17:a4:5e:80:50:11:cb:2d:7d:ab:
    73:8b:44:26:37</p>

<p><strong>publicExponent:</strong> 65537 (0x10001)</p>

<p>注意我的粗体两个标号，我发现一个非常好的idea去处理类似的问题，可能是前辈们故意这样设计的，用脚本语言就能轻易的解决。
think python : 就是用find函数去查找&#8221;modulus:&ldquo;字符串，然后后面就是你想要的东西了
<strong>到底取多长？？</strong></p>

<p>1.可以计算</p>

<p>2.看下一个标号，如果顺序不变，则好办了</p>

<p>index1 = result.find(&ldquo;modulus:&rdquo;)
index2 = result.find(&ldquo;publicExponent:&rdquo;)</p>

<p>这样差值就是你要的东西了。</p>

<p>当然差值取出来的字符串，中间还是有很多的 \n \t space
这是必须去掉的，而且根据输出</p>

<pre><code>    00:be:30:36:c1:63:35:a2:02:dd:f8:83:86:f5:e4:
ef:a2:75:9f:02:56:94:ba:a5:dc:76:59:1b:b6:4c:
3e:80:1b:10:c0:c6:d4:8f:0d:85:1c:81:25:21:5d:
19:56:bd:f3:74:17:a4:5e:80:50:11:cb:2d:7d:ab:
73:8b:44:26:37
</code></pre>

<h3><strong>可以用字符串的split(分隔符&#8221;:&ldquo;&rdquo;)来轻松解决!!!perfect!!!!</strong></h3>

<pre><code>def remove_redundent(s):
    l = []
    for ch in s:
        if ch != " " and ch != "\n":
            l.append(ch)
    s = "".join(l)
    #print s
    l = s.split(":")
    #remove redundent 0x00
    if len(l) &gt; keylength/8:
        del l[0]
    #print l
    return l
</code></pre>

<p>至于反转嘛，l = l[::-1] 这样</p>

<p><strong>全部几十行代码如下,大家可以直接用，以后用openssl取数，再也不用手工咯~</strong></p>

<pre><code>import os,re
import subprocess
import sys

#openssl commandline
#openssl genrsa -out key64.pem 64
#openssl rsa -in key64.pem -noout -text

#cammand
#Usage: python pk_extract.py [-p] key64.pem
#Usage: python pk_extract.py [-c] key64.pem 

#execute command
def execute_cmd(cmd):  
    r = subprocess.Popen(cmd, stdout=subprocess.PIPE).stdout
    text = r.read()  
    r.close()  
    return text

#commandline paramater process
from optparse import OptionParser
optParser = OptionParser()
optParser.add_option("-p","--privExpprint",action="store_true",dest="priv",help="optional:print privExp")
optParser.add_option("-c","--cinvoke",action="store_true",dest="cinvoke",help="optional:specialize for c invoke")
(options,args) = optParser.parse_args()

if len(args) != 1:
    print "Usage: pk_extract.py [OPTION] PEM_FILE"
    print "Extract key information from the PEM file. Default behavior is extracting"
    print "the modulus and the public exponent."
    print ""
    print "Options:"
    print "  -p   extract also the private component"
    print "  -c   output in special string form for programming use"
    exit(1)


pemFileName = args[0]

#openssl command:fetch .pem's modulus &amp; privateExponent &amp; publicExponent
cmd = "openssl rsa -in " + pemFileName + " -noout -text"  
try:
    result = execute_cmd(cmd)
except OSError, e:
    print &gt;&gt;sys.stderr,"Cannot execute '" + cmd + "'"
    exit(1)
#print result

def fetch_key_length(s):
    index1 = result.find("Private-Key")
    #add index to ( -&gt; (x bit)
    index1 += 14
    index2 = result.find("bit")
    index2 -= 1;
    temps = s[index1:index2]
    #print temps
    return int(temps)

#fetch keylength
keylength = fetch_key_length(result)

#configaration LINEWIDTH &amp; SHIFTWIDTH
LINEWIDTH = 76
SHIFTWIDTH = 4

#caculate numoflinewidth
numoflinewidth = (LINEWIDTH - SHIFTWIDTH + 1) / 6
#print numoflinewidth

def remove_redundant(s):
    l = []
    for ch in s:
        if ch != " " and ch != "\n":
            l.append(ch)
    s = "".join(l)
    #print s
    l = s.split(":")
    #remove redundant 0x00
    if len(l) &gt; keylength/8:
        del l[0]
    #print l
    return l

def shiftwidth_print():
    for i in range(SHIFTWIDTH):
        sys.stdout.write(' ')

def format_print(varName,l):
    #for c invoke
    if options.cinvoke:
        print "%s:{" % varName,
        for i in range(len(l)):
            print "%s" % l[i],
        print "}",
        print ""
        print ""
    else:
        print "%s %s %s[%d] = {" % ("const","DIGIT_T",varName,keylength/8)
        shiftwidth_print()
        tempnum = 1
        for i in range(len(l)):
            print "0x%s," % l[i],
            if tempnum &gt;= numoflinewidth:
                print ""
                shiftwidth_print()
                tempnum = 0
            tempnum += 1
        print ""
        print "};"
        print ""

#fetch modulus &amp; publicExponent
index1 = result.find("modulus:")
index2 = result.find("publicExponent:")
s = result[index1+8:index2]
l = remove_redundant(s)
l.reverse()
format_print("modulus",l)

if options.priv or (not(options.priv) and options.cinvoke):
    #fetch privateExponent:
    index1 = result.find("privateExponent:")
    index2 = result.find("prime1:")
    s = result[index1+16:index2]
    l = remove_redundant(s)
    l.reverse()
    format_print("privExp",l)

#fetch publicExponent
index = result.find("publicExponent:")
ch = result[index + len("publicExponent:") + 1]
l = []
if ch == "3":
    l = ["03"]
elif ch == "6":
    l = ["01","00","01"]
else:
    print "unhandled publicExponent."
    exit(1)
format_print("pubExp",l)
</code></pre>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-25T20:43:16+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/08/25/compiler-perspective-oo-object-model-lession-1/" itemprop="url">Compiler Perspective Oo Object Model Lession 1</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>compiler&rsquo;s perspective:</h2>

<h2>玩转oo对象模型(1) 之 初窥c++对象模型</h2>

<hr />

<p><strong>copyright: KIRAlzn</strong></p>

<p><strong>自我介绍: USTC研一学生，目前在intel pccg department实习，研发岗</strong></p>

<hr />

<p>第二篇来了，这次篇幅不能那么长了，得简短一点了，xixi。<strong>说好的oo对象模型，我一定能讲清楚，很久以前自己就已经写过至少5篇关于object model的文章</strong>，只是自己写着玩的，自己保存用的，怕以后忘记了，这次既然要发文章，就好好把以前的东西有条理的整理下。</p>

<hr />

<p><strong>1.本人读过inside the c++ object model ,  effective c++ , more effective c++ , c++沉思录，c++ primer 等书</strong></p>

<p><strong>2.编译器写过 minijava -> c 的代码生成,用prefix算法设计过java->c的对象模型存储，包括最难的minijava->x86的直接生成，意味用最低级的x86去直接模拟高度封装的java</strong></p>

<p>看过轮子哥专栏的朋友都知道，<a href="http://zhuanlan.zhihu.com/vczh-nichijou/19796639">http://zhuanlan.zhihu.com/vczh-nichijou/19796639</a></p>

<p>轮子哥的理念我也是很推崇的，他其中写道&#8221;譬如说我大四尝试并最终成功的一个问题——怎么把C语言编译成x86&#8221;</p>

<p>其实我看到这里，我偷偷的小happy了一把，虽然我离轮子哥的水平还相差十万八千里，但是我觉得他还是识货的，他尽然提到这个东西。</p>

<p>1.不过他是大四完成的，而我是研一上半学期完成的。</p>

<p>2.不过他做的是c -> x86 ，我做的是minijava -> x86，当然他肯定不能包含全部c的语法，我当然也是。</p>

<p>3.直接把minijava->x86，我个人认为难度系数应该是c->x86的10倍。因为java是面向对象的语言。</p>

<p>我几乎2个多星期不眠不休，连吃饭，睡觉都在想问题，我设计了几种架构，后来连续推翻重写，最后才想到一种方法很适合，当然期间遇到很多问题，我都一一解决，包括编译器还支持自我递归，要知道一个函数调用自己，怎么样保持堆栈平衡呢?</p>

<p>至于我是怎么设计的，有很多心得。我还想专门开个专栏去解释我到底是怎么想的。</p>

<p><strong>3.研究过信息安全相关</strong></p>

<p><strong>所以深知c++对象模型的机理，才敢操刀 oo对象模型的相关文章。</strong></p>

<hr />

<p>首先还是用我自己的话给 object model 下一个定义:</p>

<p>当你用  Base* b = new Base(); 的时候，你应该考虑，此时发生了什么？考虑内存怎么样分配的? 此时是单一继承呢，还是多重继承呢？ 虚函数表应该长成什么样？ 多重继承又因为比如(微软专利:虚基类虚函数表技术)菱形多重继承导致的数据二义性问题呢？最最关键的，b指向内存中的哪里？？</p>

<p>放心吧，这些我都会讲清楚的。但我还是喜欢一步一步深入，带我一步一步引导，不是隐刀，和dota没关系，要不写篇dota攻略吧，xixi</p>

<p>先看一段我认为入门最好的，最有趣的小程序，可能有点毁三观(第一反应:这tm也行?怎么做到的？，高手飘过，谢谢)，不过没关系，这可以充分展示对象模型。</p>

<p><strong>请欣赏：深入理解oo对象模型4部曲</strong></p>

<hr />

<h3>1.第一部</h3>

<pre><code>    #include &lt;iostream&gt;
    using namespace std;

    class Base{
    public:
        virtual void f(){cout&lt;&lt;"Base"&lt;&lt;endl;}                        
    };

    class Derived:public Base
    {
    private:
        void f(){cout&lt;&lt;"Derived"&lt;&lt;endl;}
    };

    int main()
    {
        Base* bp = new Derived();
        bp-&gt;f();
        return 0;
    }
</code></pre>

<p>答案是什么？</p>

<p>毫不犹豫的回答，输出 Derived</p>

<p>ok，答案是没问题了，这个不就是多态嘛？ 没错，就是多态，但是注意，</p>

<h4><strong>注意，我飘红的关键字，private修饰的fuction f()，这里好像违反了c++语法？</strong></h4>

<p>因为对象是不能直接访问类的private成员函数的，对不对？</p>

<p>这tm也行？</p>

<p>如果不深入探讨，仅仅认为就是多态而已，当然也行。。。不过打破砂锅问到底的精神还是值得赞扬的!!!!!</p>

<hr />

<p><strong>note:
注意，我举这个例子的更深层次的意图：这就是为什么说 多态 ，是运行期绑定？</strong></p>

<hr />

<p>提前给出答案:后面有详细解释，不懂没关系。</p>

<p><strong>是吧，运行期绑定，我可以负责任(写过编译器)的告诉你，编译期的时候编译器根本不知道，只有当你程序跑起来的时候，去相应位置调用了相应位置的函数指针，才知道你到底运行的是什么函数，so，运行期(动态)绑定就是这个原因!</strong></p>

<p>好吧，第一个程序如果还是不过瘾，请欣赏第二个程序。</p>

<hr />

<h3>2.第二部</h3>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class Base{

public:
    virtual void f(){cout&lt;&lt;"Base"&lt;&lt;endl;}
};

class Derived:public Base {

private:
     void f(){cout&lt;&lt;"Derived"&lt;&lt;endl;}
};

 typedef void (*Func)();

int main()
{

    Base* bp = new Derived();

    Func fp = (Func)*(int*)*(int*)bp;

    fp(); 

    return 0;

}
</code></pre>

<hr />

<p><strong>这tm是什么？为什么fp尽然能调用bp对象模型里面的函数？这里面有什么猫腻吗？
此时应该引发思考，bp指向的对象模型到底长成神马模样？能让 人 如此用指针摧残？</strong></p>

<hr />

<p>ok,如果还不过瘾，我再敲一个，更毁三观的程序，可以叫它   ->   hook虚函数表 , 不行，这样叫不准确，就叫他 object hook 吧，其实就hook了一个函数指针而已。</p>

<hr />

<h3>3.第三部</h3>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class Base{

public: virtual void f(){cout&lt;&lt;"Base"&lt;&lt;endl;}
};

class Derived:public Base {

private: void f(){cout&lt;&lt;"Derived"&lt;&lt;endl;}

};

void hookf() { cout&lt;&lt;"you are being hooked"&lt;&lt;endl; }

typedef void (*Func)();

int main()
{

Base* bp = new Derived();

Func fp = (Func)*(int*)*(int*)bp;

*fp = hookf;

bp-&gt;f();

return 0;
}
</code></pre>

<p>注意，这里*fp = hookf; 是编译不通过的，因为 vtable是被编译到 .data段 ，是只读的，g++下:</p>

<p>a.cpp:29:11: error: assignment of read-only location ‘* fp’</p>

<p><strong>但是，在windows下，没有神马是不能修改的，比如(VirtualProtect,VirtualProtectex,修改CR0的写保护位，MDL等等)，这里不详细讨论。</strong></p>

<p>所以说，如果能改，则hook一个函数指针有多么容易？？？</p>

<p>如果改了之后，bp->f();输出什么，应该很明了了。</p>

<hr />

<h3>4.第四部，来了，不像3一样，4是可以直接跑的，所以说，c++对象模型中。。vptr的设计。。。 -> hook 整张虚函数表</h3>

<p>windows下cl.exe编译 ， linux 下 g++ 编译均可以。</p>

<p>这个是我写的 <strong>监控虚函数表差异定位</strong> 时候的程序，我简化到最简。</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
using namespace std;

void Hook_all_Vtable(int* pObjectBase);

void hookfunc();

class Game {
int a;
int b;
string s;
public:
virtual void add(){cout&lt;&lt;"virtual function add() being called:0x"&lt;&lt;endl;}
virtual void sub(){cout&lt;&lt;"virtual function sub() being called:0x"&lt;&lt;endl;}
virtual void mul(){cout&lt;&lt;"virtual function mul() being called:0x"&lt;&lt;endl;}
virtual void divv(){cout&lt;&lt;"virtual function div() being called:0x"&lt;&lt;endl;}
};

void hookfunc() { cout&lt;&lt;"you are being hooked."&lt;&lt;endl; }

typedef void (*Func)();

int main() {

Game* gp = new Game();

Hook_all_Vtable((int*)gp);

gp-&gt;add();

return 0;

}

void Hook_all_Vtable(int* pObjectBase)
{
int* allocp = (int*)calloc(1,100*sizeof(long));
memcpy(allocp,(void*)(*pObjectBase),100*sizeof(long));
*pObjectBase = (int)allocp;
*allocp = (int)hookfunc;
}
</code></pre>

<p>程序的细节，不做任何过多的解释，初窥嘛~，细节请听下回分解。</p>

<p>此时，一段可以直接跑的程序出炉了。</p>

<p>输出什么，相信大家很明白。</p>

<hr />

<p><strong>这tm就随意的就hook整张虚函数表了？？？？？？</strong></p>

<p><strong>c++对象模型到底长成神马模样??</strong></p>

<p><strong>是不是有点意思了？？？？？？？？？</strong></p>

<p><strong>通过这段最最简单的hook虚函数表程序，大家可以发现，其实玩转c++对象模型其实不是难事，希望大家跟着我一点一点学习，我保证能解释清楚。</strong></p>

<hr />

<p>最后还是要总结一下下：</p>

<hr />

<p><strong>note：
注意，所以这里说，c++有指针，所以可以肆意访问c++的对象模型，去hook里面的对象模型里的函数指针，比如堆溢出，对喷射等技术，所以c++对象模型在所有人都是好人的情况下，模型是完美的，是B.lippman在cfront的时候设计出来的完美模型，但是。
所以说，java做的比较彻底，没有指针，就不让你用指针，这样你怎么去遍历java对象模型的函数指针呢？是不是变得更安全了？？？而且java还有反射机制，也是存在于java对象模型中，所以，就是java，就是不让你用指针。就用reference吧。
but，我要说明一下：
不要认为c++对象模型不安全就不用c++，hook函数指针，不是因为c++对象模型的设计而造成的，说白了，
就是结构体里面有函数指针，然后函数指针被hook了，就这么简单!我们亲切的称之为 object hook
只要你用oo，注意，不是c++能oo，但是c不能oo，其实c也能oo，很easy(自己搞vptr和vtable)
所以，基本上，只要你用oo，就会存在函数指针，就有可能被hook，所以错不在c++，请大家明示!!! 但是c++允许指针去遍历虚函数表，这就不对了,呼呼。
java么有指针，看，多彻底？？</strong></p>

<hr />

<blockquote><p>注意:c++的虚函数表，是被编译器编译到 .rodata
段，即只读段，你是不能直接修改虚函数表里面的函数指针，当然在windows下，没有神马是不能修改的，比如(VirtualProtect,VirtualProtectex,修改CR0的写保护位，MDL等等)，但是可以修改vptr的指向，即可以hook整张虚函数表，因为vptr是在结构体里，当然看看你是分配在
栈上，还是堆里，还是.data段咯，这些都是可以直接修改(参考第4个程序)的， .text 和 .rodata是只读的。</p></blockquote>

<h2>note:</h2>

<h3>这里插播一条我写的小程序，和对象模型没关系，仅供娱乐:一定要运行一下，看下输出，嘻嘻。</h3>

<pre><code>#include &lt;stdio.h&gt;
int main()
{

    int i = 0x00752065;
    int j = 0x00766f6c;
    short k = 0x0049;
    printf("%s %s%s",&amp;k,&amp;j,&amp;i);

    return 0;
}
</code></pre>

<p>note：</p>

<blockquote><p><strong>由以上语言，当年一起开发c编译器和unix的男银最后得了图灵奖，但是c++这么庞大编译器的男银却没有得图灵奖，这是又说明了神马？？</strong></p>

<p><strong>(又想到了特洛伊木马，有兴趣的童鞋可以自行去了解，蛋生鸡鸡生蛋的问题，得想清楚呦)</strong></p>

<p><strong>各位看官有自己的观点，是吧。</strong></p></blockquote>

<p>当然第一篇，只是随便谈谈c++对象模型的一些有意思的东西，并没有具体分析，因为初窥嘛，以后会讲清楚的，请关注我呦。</p>

<p>请关注下一篇，谢谢。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-25T20:36:21+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/08/25/compiler-and-naturelanguageprocess/" itemprop="url">Compiler and NatureLanguageProcess</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>编译器perspective &amp; 自然语言处理</h1>

<hr />

<p><strong>copyright: KIRAlzn</strong></p>

<p><strong>自我介绍:  USTC研一学生，目前在intel pccg department实习，研发岗</strong></p>

<hr />

<p>最喜欢吴军博士的一句话，和我本人的学习理念比较接近，所以对他的书也非常着迷：<strong>技术分为术 和 道，术 是具体做事的算法，道是其背后隐藏的根本机理。
</strong></p>

<p>就像吴军博士说的那样，</p>

<p>1.高大上的自然语言处理背后模型机理尽然如此简单(当然细节不简单)</p>

<p>2.怎么像你奶奶解释搜索引擎？其实搜索引擎的背后机理其实简单的不能再简单了，就是布尔运算!!!三句话就能讲明白，一是下载尽可能多的网页，二是建立索引，三是根据相关性给网页排序!没了，这就是搜索引擎，任何智能的搜素引擎都逃不出布尔运算的框架。</p>

<p>3&hellip;..</p>

<p>以我个人愚见，首先得深刻理解道，然后再去发扬术会比较好。因为只有深刻理解道，然后才能举一反十!!!然后在你接触新东西的时候，能对以前学的知识加以联系，发现其中的隐含机理的相似性。<strong>并能把一个领域的经典研究方法带到另一个研究领域。
</strong></p>

<p>所以本人看书经常是反复思考，一本书可能要看很多遍，反复琢磨，所以现在每看一本新书，总能把书上画的乱七八糟(- -，看过我任何书or笔记的小伙伴们都知道)，这些是什么？</p>

<p>一方面是这本书的前后联系，</p>

<p>另一方面是我学过该知识之后进行的一些大胆尝试，举一反三的经验心得，</p>

<p>最后也是最重要的，就是我和以前的知识进行对比。</p>

<hr />

<p><strong><strong>先交代一下:</strong></strong></p>

<p>1.<strong>这是我第一篇</strong>，突然想写点有质量的文章，来和大家分享知识，写的不好的地方欢迎拍砖。</p>

<p>2.本人写过编译器，编译器根本不是什么高大上的东西，本质就是一种数据(信息/语言)处理的方法而已，和处理其他数据一样，并和处理自然语言进行对比</p>

<p>3.下一篇是关于学完编译器之后，应该掌握的技能，即进阶信息安全的基础：</p>

<blockquote><p><strong>关于一段c/c++代码，编译之后，生成怎么样的x86，calling convention，prolog/epilog，caller-saved/callee-saved register，堆栈平衡，所有变量的内存分布，函数符号修饰成什么样，静态链接，动态链接，地址修正，链接指示对编译过程的影响，如dllimport,dllexport,#pragma，函数声明顺便提一下链接器，以及windows下病毒的运行机理，我不会重点写什么是动态链接，而是解释为什么动态链接，及其背后隐藏的原因</strong></p></blockquote>

<p>4.下一篇关于OO object model，本人对OO有一定了解，封装，继承(单一，多重，怎么解决菱形多重继承数据二义性问题，微软怎么解决？gcc怎么办？分析我们用的 prefix算法 实现对象模型的继承 ，并给出拓展)，多态，这篇以c++为基本，讲述c++ object model，并给出c++为什么转换指针会变化(Base* b = new Derived();编译器怎么理解对象模型的，怎么就能多态？？对象模型长成什么样，怎么样会造成覆盖，遮蔽？和多态在对象模型上有什么区别？遮蔽，覆盖为毛就不能多态了？)，并分析一下c++对象模型优缺点，容易受到什么攻击(堆溢出，堆喷射)，虽然hook 函数指针本质不是c++语言本身造成的。。但是c++对象模型如果对于大家都是好人的情况下，是很优秀的对象模型，but。。。</p>

<p>5.下一篇准备写关于高级(多核)操作系统内核的理解，当然是基于MIT的 xv6 和 Yale的pios ,关于 Vitrual Memory:逻辑地址->线性地址->物理地址, fork/join/ret ,copy-on-write&hellip;..</p>

<p>6.再下一篇可能是关于 内存数据库 新存储方式的新实现(本人拍脑袋想的)，并和 sqlite3，nosql，redis 等内存数据库进行 性能，实现方式 的比较</p>

<hr />

<p>本文参考了<strong>数学之美，编译器(虎书 和 龙书)</strong>，和在USTC老师教的，加上我自己写编译器过程的理解，</p>

<p>最后加上我自己设计的<strong>final project：code generation(minijava->x86,AT&amp;T,IA32)</strong></p>

<p>本人花了一个学期的时间，认真的写了一个编译器,差不多由以下部分组成:</p>

<p>miniJava compiler -></p>

<p>implement: lexer,parser,AST,elabrator,garbage collector(Gimple algorithm)，
           code generation(minijava->C), code generation(minijava->java bytecode),
           code generation(minijava->x86,AT&amp;T,IA32),
           object model(encapsulation,single inherit,polymorphism)</p>

<p>theory: exception,closure,SSA(static single assignment),
            register allocation(graph coloring)</p>

<p>optimiztion：CFG(liveness analysis，Reaching Definition analysis),DFG,SSA, Lattice, register allocation(graph coloring)</p>

<p><strong>写本文的目的：
写完编译器，发现编译器更多的是一种数据处理的方法，而不是什么高大上的东西，我写这篇文章的目的，是想任何读完我文章的人，知道编译器到底在干吗，编译器到底能干些什么？学了编译器之后有神马好处？学完编译器应该掌握什么技能？？？</strong></p>

<p>我会不断提出问题，引发读者的思考，我喜欢有逻辑的思考问题，希望这样能让文章更有逻辑性。</p>

<p>而且我写东西，不喜欢记流水账，比如这个应该怎么怎么样，而是写为什么要这样，我喜欢搞清楚其背后的原因。</p>

<p>本文可能会很长，我会从背后隐含的原理去写，而不去探讨高大上的技术。</p>

<p>好了，废话不多说，正文开始。</p>

<hr />

<h3><strong>1.先说说自然语言处理吧(本人不是很懂)，一些基本概念，懂行的人直接跳过，谢谢。</strong></h3>

<p><strong>a.首先古老的文明为什么会出现文字？</strong></p>

<p>因为文字仅仅是信息的一种载体，意图还是想把信息记录下来，本质还是信息，古代没有文字的时候，人们比如到了冬天冷，会发出一些 ，&#8221;嗖嗖&#8221;的声音，肚子饿了，会发出一些什么什么声音，然后由于声音太多，信息太多，人们无法记住，也无法统一，如此才出现了文字，没有为什么，就是因为没有人能记住所有的声音，</p>

<p>这样就需要一种文字，去记录那些信息。</p>

<p><strong>b.有了文字，就一定会有语句，N个文字用不同的语法规则去拼凑生成的语句，不同的语法规则，生成不同的语言，这个很好理解。</strong></p>

<p><strong>c.随着文明的发展，信息越来越多，但是文字的数量不能成倍的增长，否则也不便于记忆，这样就出现了聚类，把一些相同概念的意思，归纳用一个字(词)去表示，比如一次多义，&#8221;日&#8221;表示太阳，表示太阳早上从东边升起，从西边落下，所以又可以表示一天，等等。</strong></p>

<p>第c条就是所谓的一词多义，绝对是困扰古今中外语言学者，包括计算机科学家的一个大问题，也就是理解这个词的意思，需要参照上下文(context)</p>

<p><strong>d.常识。</strong></p>

<p>The pen is in the box.</p>

<p>The box is in the pen.</p>

<p>第一句正常人都懂，第二句有点坑了，不过外国人很容易理解，由于外国人的常识，经验，所以外国人立马就明白，第二句的pen的意思是围栏。</p>

<p>自然语言处理，想分析语句的语义就又多了一坑。</p>

<p>其实我就是想说 c 和 d 是基于 编译器技术的 lexer+parser分析 自然语言的语义 上的一个大坑, 这个就是困扰计算机科学家，语言学家多年，以及阻碍处理自然语言的原因之一。</p>

<p> <strong>e.为什么要分词？</strong></p>

<p>像英语这种基本不需要，因为空格就是活生生的分隔符(但是对于手写识别英文，空格不明显，还是需要分词的)，但是对于 中，日，韩，泰 等语言，比如 今天我学会了开汽车，中间没有分隔符，所以需要分词。</p>

<p><strong>分词其实也是一坑，比如：
此地\安能\居住，其人\好不\悲伤
此地安\能居住，其人好\不悲伤</strong></p>

<hr />

<h3><strong>2.为什么要扯自然语言处理，这个和编译器到底有什么关系？</strong></h3>

<p>听我慢慢道来。</p>

<p>自然语言处理，其实就是处理比如，今天\我\学会了\开\汽车。 you \ are \ so \ cool.</p>

<p>而基于编译器技术的 lexer + parser ，则也是一样， 今天\我\学会了\开\汽车，不过通常是处理计算机语言，类似，static void main(string[] args)等等。</p>

<p><strong>so:
a.自然语言处理，处理的是自然语言，比如上面举得例子，The box is in the pen. 定义的上下文相关文法，即其中词语的意思不能确定(一次多义)，需要结合相应的语境才能知道pen的意思，和大家做的英文完形填空是差不多的。
b.编译器的如java语法，static void main()定义的是上下文无关文法，注意，上下文无关文法的好处就是，只要你定义的好，不会发生歧义，因为不存在一次多义，稍稍举个小例子。</strong></p>

<p>exp -> NUM
       -> ID
       -> exp + exp
       -> exp * exp</p>

<p>遇见exp就可以无条件分解为后面这四种情况，然后再不断的递归下降(recursive decendent parser/top-down parsing/predicative parsing)迭代，解析语句。</p>

<p>为什么说只要定义的好呢？因为我们lab用的是ll(k)，也就是说，只支持从左到右parser，如果出现左递归就会出现永远循环下去，因为是无条件分解。</p>

<p>定义左递归上下文无关文法坑：</p>

<p>a.左递归->右递归</p>

<p>b.歧义->提取公因式</p>

<p>一些其他编译器应该支持lr(k)</p>

<p>到这里看不懂没关系，这里只是随便提提。</p>

<p>我只是想说，像编译器编译的 c/c++/java&hellip;，包括sql语句，都是上下文无关文法，都可以用基于编译器的技术，lexer + parser 去解决问题</p>

<hr />

<p><strong>ok，有的人就要问了，那为什么基于编译器的技术，lexer + parser 把自然语言，先分解为一系列的token，之后生成语法树，然后用llk or lrk 去遍历这棵树，然后进行 语义分析， 为什么不能很好的处理自然语言？</strong></p>

<hr />

<p><strong>误区：原本科学家以为，随着语言学家对自然语言语法的概括越来越完备，计算机计算能力又在逐渐提高，基于编译器的技术应该能够很好的解决自然语言处理。</strong></p>

<p><strong>but：一条很简单的上下文相关的语句，却能分析出很庞大复杂的 AST(parser 返回结果是 语法树)， 如果再复杂一点，基于语法树的分析根本行不通。</strong></p>

<p>考虑一句很长的文言文，此处省略100字。</p>

<p>结论：所以说，基于编译器技术的lexer + parser 只适合解决上下文无关文法 定义出的语言。</p>

<p>那上下文无关文法 就不能定义 自然语言了？？要不试试看？</p>

<p>反正我不试。。原因如下：</p>

<p><strong>a.想要通过上下文无关文法定义汉语的50%语句，语言学家不仅会累死，而且由于一词多义，需要结合语境，所以还要在文法里定义各种语境，可以想象那个工作量  吗
b.定义的上下文无关文法越多，越容易出现歧义(提取公因式)，而且会出现左递归(改成右递归)，如此，如此，会疯掉的。所以 无法涵盖所有语言语法不说，还有歧义，这个是要做成实际应用的，这样能忍吗？</strong></p>

<p>如此说来，20世纪50年代到70年代，用  基于编译器技术 lexer + parser 分析自然语言的语义，绝对是科学家们走的弯路。</p>

<p>直到20世纪70年代，才有先驱重新认识这个问题，基于数学模型和统计，自然语言处理进入第二个阶段。</p>

<hr />

<p><strong>再总结一下结论： 基于编译器技术 lexer + parser 分析语言的语义， 只适合 上下文无关文法， 而上下文无关文法 无法(不容易)定义 自然语言，so，不能用lexer + parser 去分析自然语言的语义。</strong></p>

<hr />

<h3><strong>3.那到底怎么处理自然语言呢？(本文不会详细写怎么处理，只写基本原理)，懂行的请自觉跳过，谢谢。</strong></h3>

<p><strong>从规则到统计，用数学的方法去描述语言规律。</strong></p>

<p>注意，统计语言模型的产生初衷是为了解决语音识别问题，也就是说 一句话，让你分析，这句话到底是不是具有正确意义的自然语言。</p>

<p>用统计的思想思考：一个句子，由特定的单词串组成，s = w1,w2,&hellip;,wn ,一个句子有意义的概率是 P(s) ,</p>

<p>由条件概率很容易得到 P(s) = P(w1) * P(w2 | w1) * &hellip;.. * P(wn | w1,w2,&hellip;,wn-1)</p>

<p>只要算出这个语句有意义的概率，不就能判断到底这句话有木有意义了呢</p>

<p>但是越到后面这个条件概率越难算了，怎么破？</p>

<p>没关系，马尔可夫为我们想了一个偷懒而且颇为有效的方法就是，假设 一个词 wi 出现的 概率 只和它前面的那个词 wi-1 有关系，</p>

<p>所以公式就简化为 P(S) = P(w1) * P(w2 | w1) * P(w3 | w2) *  &hellip;..  * P(wn | wn-1)</p>

<p>当然，这个模型，很多人第一次见到，肯定会问，就这东东，能分析这么难文法的自然语言。。。。吗？</p>

<p>答案是肯定的，Google 的 罗塞塔 系统，仅仅开发2年，就是基于类似这种数学统计模型，就一鸣惊人的获得了 NIST 评测的第一。</p>

<p>当然，对于高阶一点的语言模型，其他模型，模型的训练，零概率问题，我在本文不想深入讨论，讨论的重点，主要还是想放在编译器上面。</p>

<p><strong>一点点思考：
说到这里，说一点题外话。本人还写过内存数据库，所以，需要支持sql语句，为sql语句也写过 lexer 和 parser，用的也是上下文无关文法。
考虑如果sql语言，如果发展足够强大，就像自然语言一样，语法越来越多，会不会出现 聚类(一词多义) ？如果出现聚类，那根据我的结论，
lexer + paser这种方法不work了，那是不是得用到 自然语言处理的 某些方法，或者其他方法？？？
由于目前的语言c/c++/java/sql 还是处于上下文无关文法就可以定义的语言，有个度(界限)的问题，如果跨越到自然语言，则以前的方法根本不能用了，是不是得考虑新的技术。
啧啧，随便说说。</strong></p>

<hr />

<h3><strong>4.关于自然语言处理 和 编译器相关技术处理 的浅薄关系 在上面已经说过了，接下来就是我要讲清楚，编译器到底在干什么？</strong></h3>

<p>我之前说过，编译器也是对一种语言的处理过程，所以上文和自然语言处理进行了对比，然后引发了一点点小思考。</p>

<p>ok，书上说编译器就是把高级语言翻译成低级语言，忘了，书上好像是这么写的。</p>

<p>不过我理解的编译器应该是这样，</p>

<p><strong>a. 编译器会经过 lexer + parser + elabraor + code generation : IR(N种)  for optimization + 可能还链接一个garbage collector  ->   然后生成object file(目标文件)，注意目标文件还是不能运行，但是就差那么一点点，这一点点是什么(对于外部符号，编译器不知道，只能进入符号表，等待链接器来修正)？</strong></p>

<p>比如你  cl /c main.c  这样只编译不链接，如果出现编译器不认识的符号，没关系，反正生成目标文件，那些符号就进入了符号表，等链接器下一步工作。</p>

<p>但是你 cl main.c ，这样既编译又链接，如果有不认识的符号，直接报错（假设你其他目标文件也木有这个符号）</p>

<p><strong>总结：等链接器，把其他的目标文件link到一起(主要是地址修正)，然后生成可执行文件(静态链接/动态链接/动态链接静态加载/动态链接动态加载，不一样)， 这样就生成了可执行文件 .exe / a.out &hellip; 芯片上跑去吧</strong></p>

<p>详细细节留给下一篇吧，要写就停不下来。。。</p>

<p><strong>b. 编译器确实是把高级语言翻译成低级语言，但是其中会经过很多种IR(中间代码)，大部分原因是因为优化，像gcc就经过N种优化，然后生成一个最简的x86机器码，然后跑在intel的芯片上，当然ARM,MIPS都可以。。。当然你翻译成java的bytecode ，在虚拟机上跑，都是可以的。</strong></p>

<p>IR嘛，举个例子，比如</p>

<p>第一步我就要对AST进行优化，优化通常有 常量折叠，代数简化，标量代替聚量， 常量传播，拷贝传播，死代码删除，公共子表达式删除等等</p>

<p>ne.g.: a = 0+b    ==>  a = b
ne.g.: a = 1<em>b      ==>  a = b
ne.g.: 2</em>a            ==>  a + a
ne.g.: 2*a            ==>  a&lt;<1         (strength reduction)
ne.g.: *(&a)          ==>  a
看吧，常量折叠很好理解吧，就是直接把AST给改了，
这里暂时不讨论其他优化。
note:
像a++这种，我们称之为 &ldquo;语法糖&rdquo; 的东西，可能不是在优化器里把改为 a = a + 1; 可能在 parser 里面看到 就直接改了，呼呼。
当然 a += 1,也是赤裸裸的  &ldquo;语法糖&rdquo;
第二步，我可能要经过CFG(control flow graph)(SSA在后面讨论)
那就要把IR翻译成三地址码，然后以跳转为分界线，把不跳转的部分组织成块，最后组织成图形结构
第三步，可能是DFG优化，利用数据流方程进行优化
第四步，可能是活性分析，寄存器分配(图着色)
第五步，可能是基于离散数学，格(Lattice)的优化
第N步， 等等 。。。。。。</p>

<p><strong>note:小插曲：
编译器优化程序员永不失业理论 ： 因为没有一种优化能够总是起好的作用(视具体情况而定)，所以任何一种算法都不能把所有程序化简到最简。。。所以。。
但有一种优化总能起好的作用，嘻嘻，那就是寄存器分配(前提是你得有几个寄存器。。。)，一定会让你的程序变快。</strong></p>

<p>要不再专门写一篇，讨论编译器优化，我有很多话想写。</p>

<p>算了，详细不做讨论，在这里只想说，很多编译器为了进行优化，生成好多好多种IR，在每一层IR上进行不同的优化，就是为了用数学的方法，去不断简化程序员写的代码，因为不同的IR对不同的优化有不同的功效</p>

<p><strong>->目的很明显，就是为了生成最优的机器码</strong></p>

<p><strong>note：
为什么编译器要分 lexer + parser + elabraor + code generation 这么多层？ 合并几层不行吗？
      答案是当然可以，不过为什么这样分，有它的道理，原因就是模块化，比如，有专门的人研究lexer，比如有Flex等工具，专门的人研究parser。。。但一层一层向下，向上暴露的接口当然是一致的，这样的好处就是，可以专门研究某一层算法，然后直接替换某一层。</strong></p>

<h3><strong>初窥了什么是编译器，接下来，我想一步一步分析，到底lexer + parser + elabraor + code generation 这么多层，每层编译器在搞什么？</strong></h3>

<ol type="a">
<li><p>lexer</p></li>
<li><p>parser</p></li>
<li><p>elabrator</p></li>
<li><p>code generation</p></li>
<li><p>讨论 exception,closure,SSA(static single assignment) 是怎么样实现的</p></li>
<li><p>讨论一下garbage collector</p></li>
<li><p>optimization</p></li>
<li><p>关于我们学校课程最后的 final project 思考，关于 java 反射机制，gc的世代收集，翻译成 go / js ，jvm ，还有本人写的 minijava 直接 -> x86，我几次推翻重写，不过最后完成了，还是很 happy (minijava没有很高深的java语法，仅仅是封装，继承，多态，我用x86模拟了而已)</p></li>
</ol>


<h4><strong>a. lexer -> translates the source program into a stream of lexical tokens</strong></h4>

<p><strong>输入: source program
输出: a stream of lexical tokens</strong></p>

<p>先举个通俗易懂的例子，比如我要对以下java程序进行 lexer，怎么做 ？</p>

<pre><code>class TreeVisitor
{
    public static void main(String[] a)
    {
       System.out.println(new TV().Start());
    }
}
</code></pre>

<p>lexer的输出，很明显是，a stream of lexical tokens :
<strong>class</strong> | <strong>TreeVisitor</strong> | <strong>{</strong> | <strong>public</strong> |  <strong>static</strong> | <strong>void</strong> | <strong>main</strong> | <strong>(</strong> | <strong>String</strong> | <strong>[</strong> | <strong>]</strong> | <strong>a</strong> | ) | <strong>{</strong> | <strong>System</strong> | <strong>.</strong> | <strong>out</strong> | <strong>.</strong> | <strong>println</strong> | <strong>(</strong> | <strong>new</strong> | <strong>TV</strong> | <strong>(</strong> | <strong>)</strong> | <strong>.</strong> | <strong>Start</strong> | <strong>(</strong> | <strong>)</strong> | <strong>)</strong> | <strong>;</strong> | <strong>}</strong> | <strong>}</strong></p>

<p>看一下 Token结构体长成神马样子？</p>

<pre><code>class Token
{
    public Kind kind; // kind of the token
    public String lexeme; // extra lexeme for this token, if any**

    public Integer lineNum; // on which line of the source file this token appears 目前可以忽略，只是为了输出

 ......
 }
</code></pre>

<p>看下输出,大家就明白了:</p>

<pre><code>TOKEN_CLASS: class : at line 5
TOKEN_ID: TreeVisitor : at line 5
TOKEN_LBRACE: &lt;NONE&gt; : at line 5
TOKEN_PUBLIC: public : at line 6
TOKEN_STATIC: static : at line 6
TOKEN_VOID: void : at line 6
TOKEN_MAIN: main : at line 6
TOKEN_LPAREN: &lt;NONE&gt; : at line 6
TOKEN_STRING: String : at line 6
TOKEN_LBRACK: &lt;NONE&gt; : at line 6
TOKEN_RBRACK: &lt;NONE&gt; : at line 6
TOKEN_ID: a : at line 6
TOKEN_RPAREN: &lt;NONE&gt; : at line 6
TOKEN_LBRACE: &lt;NONE&gt; : at line 6

..................
</code></pre>

<p>ok，分解为了 a stream of lexical tokens ，很明显用一个 队列 去存储它们。</p>

<p>note:</p>

<h3><strong>非常建议用队列去存储，为什么？</strong></h3>

<p><strong>1.我们lab用的是直接在parser里面一个一个直接读取lexer分解出来的Token</strong>，即不能回滚，即上一个Token还得用一个value记录下来，当然你可以</p>

<p>定义回滚几个，然后记录 rollbackToken1,rollbackToken2,rollbackToken3&hellip;.等</p>

<p><strong>2.用队列虽然浪费了存储空间，但是可以任意回滚任意个数的Token</strong></p>

<p>so，建议看具体需要。</p>

<p><strong>神马情况下会遇到回滚Token?</strong></p>

<p>比如，</p>

<p>MyVisitor v ;</p>

<p>root = new Tree();</p>

<p>由于是递归下降分析(在paser中详细讨论，看完paser再回来理解)，只能像微软的编译器一样，写c语言的时候，定义放在语句前面，如果你在中间某个地方写了，int a = fun(1,2);<strong>则微软编译器会报错，但是一个这样的小错误，微软的优化器会爆出各种错</strong>。。。让你根本就不知道哪错了</p>

<p><strong>回到正题：由于和c语言一样，本编译器算法是，前面是定义，后面是语句。</strong></p>

<p>so，检测到root 的时候 Token是个ID，没问题，但是后面发现Token 是 = 号，也就是你进入 定义和语句的 临界区域了，so，你的代码还在分析定义的代码里，怎么破？你得回滚，然后跳出整个 分析 定义的代码，进入分析语句的代码，然后 current Token 得回滚到 root (原来在=)。</p>

<p><strong>note:
但是gcc支持语句中有定义，不是因为 ANSI c 支持，而是gcc进行的拓展。
gcc怎么实现的？其实很容易，和c++/java 一样，加减符号表运算即可
gcc的c还支持bool呢，呼呼。</strong></p>

<p><strong>note:
吐槽微软编译器：
void fun(){}
这样的空函数，微软还不优化，</strong></p>

<pre><code>fun:
     push ebp
     mov ebp,esp 
     push ebx
     push esi
     push edi
</code></pre>

<p>这三个是 callee-saved 寄存器，微软还要入栈保存，是不是有点懒了，别说寄存器分配了，如果 寄存器分配(比如图着色) 只用到一个寄存器，这样入栈保存一个不就行了吗？</p>

<p><strong>note:算了，还是表扬下微软的编译器吧，比如你看到，</strong></p>

<pre><code>   push ebp 
   mov ebp,esp
   push ecx    // 而不是  sub esp,4
</code></pre>

<p><strong>为什么不用sub esp,4 ? 。。。。。。。这个原因很深刻，因为，同样是往下开辟4个byte， push ecx 用的(指x86，ARM不知道)机器码更少哦</strong></p>

<p><strong>其实我是想解释，为什么 lexer 要 translates the source program into a stream of lexical tokens ？而不分解为其他结构 ？</strong></p>

<p>想想中文为什么要分词？ eg，今天我学会了开汽车，你用指针去扫源代码的时候，扫到 unicode  &ldquo;今&rdquo; ，你能把它作为一个Token吗？明显不行，因为&#8221;今天&#8221;才是一个Token。。。那怎么样断句呢？即，怎么分词呢？最简单的方法就是查字典，这种方法最早是由北航的梁南元教授提出的。即，字典里有的词就表示出来，遇到复合词就最长匹配。</p>

<p><strong>但是最长匹配也有问题。</strong></p>

<p>比如， 上海大学城书店，你怎么分？</p>

<p>最长匹配是： 上海大学/城/书店？</p>

<p>显然不对，应该是 上海/大学城/书店</p>

<p>这里不进一步讨论。</p>

<p>好了，之前说过，像英文这样 I am so cool. 语句之间有标点符号，语句之中有空格，所以，不需要分词，Token很容易找到!!!!!!</p>

<p>代码也是这样，大部分是有分隔符(以空格分开)的，但是也有例外，比如，</p>

<p>/</p>

<p>//</p>

<p>/*</p>

<p>遇到一个/，你能武断说这个Token是 / 吗？嗯，得看看后面跟的是啥。</p>

<p><strong>回到正题，为什么要分解为a stream of lexical tokens？</strong></p>

<p>因为比如自然语言是由一个一个单词组成的，单词组成的顺序，则是语法。</p>

<p>你只有先把一个一个单词分解出来，然后去分析每个单词之间为什么这样排列(这就是分析这句话是神马语法 -> 找出它的语法规则 )，然后生成一棵语法树，存储起来。</p>

<p>分词就是lexer干的事情，它的输出就是给 parser 的输入，parser 则负责生成 AST(抽象语法树)，并传给 elabrator。</p>

<p><strong>note:
说道分词，编译器技术已经完美解决了这个问题(仅仅针对上下文无关文法)，即用 正则表达式。 NFA -> DFA</strong></p>

<p>我不想延伸，因为内容太多，以后有机会再写。</p>

<p>当然lexer有很多，比如 flex, sml-lex, Ocaml-lex, JLex, C#lex &hellip;&hellip;</p>

<p>说道这里，lexer我是否已经讲清楚了呢？？我觉得差不多了，以后有机会补充。</p>

<p> ####<strong>b. parser -> 根据 递归下降 分析算法，生成语法树</strong></p>

<p><strong>note:
recursive decendent parser/top-down parsing/predicative parsing  这几个单词是一个算法，都是递归下降分析</strong></p>

<p>想了想怎么来说这个parser，我想我还是举个实例比较容易理解! 我不喜欢把一个很简单的东西，用很多数学公式去弄的很复杂，我觉得做学术，反而应该把复杂的东西，简单化，这样让更多人能看懂其背后的机理其实很easy。</p>

<p>先随手写段程序好了,不要在意语义上的细节，只是为了说明parser工作机制。</p>

<pre><code>class TreeVisitor
{
    public static void main(String[] a)
    {
        System.out.println(new Visitor().Start());
    }
}

class Visitor 
{
    Tree l;
    Tree r;
    public int Strat(Tree n)
    {
        int nti;
        int a;

        while(n &lt; 10) 
            a = 1;

        if(n.GetHas_Right())
            a = 3;
        else
            a = 12 ;

        return a;     
    }
}
</code></pre>

<p>递归下降，可以用一个词来来概括，其实就是 while循环。</p>

<p>如果说要返回一个AST，这样当然需要先定义所有抽象语句的类，然后生成其对象，然后reference相互连起来，形成一棵树。</p>

<p>parser 输出返回一棵AST -> theAst = parser.parse();</p>

<p><strong>ast.program.T prog = parseProgram();</strong></p>

<p>&hellip;&hellip;.</p>

<p><strong>ast.mainClass.MainClass mainclass = parseMainClass();
java.util.LinkedList&lt;ast.classs.T> classes = parseClassDecls();</strong></p>

<p>&hellip;&hellip;</p>

<p>java.util.LinkedList&lt;ast.classs.T> classes = new java.util.LinkedList&lt;ast.classs.T>();</p>

<p>ast.classs.T oneclass = null;</p>

<p>while (<strong>current.kind == Kind.TOKEN_CLASS</strong>) {</p>

<pre><code>  oneclass = parseClassDecl();

  classes.add(oneclass);

}
</code></pre>

<p><strong>注意，我为什么说，递归下降就是while循环，上面漂绿的字体很明显了，当你分析某一种语法的时候，不断用while探测，如果进入下一个语法，则跳出while循环。</strong></p>

<p>再说细一点:</p>

<pre><code>int nti;
int a;

while(n &lt; 10)
    a = 1;

if (n.GetHas_Right())
    a = 3;
else
    a = 12 ;
</code></pre>

<p>函数开始的时候，先分析 &ldquo;定义&rdquo; ，分析到 int nti; 没问题，是 &ldquo;定义&rdquo; ，然后到 int a; 也没问题，是 &ldquo;定义&#8221;。</p>

<p>但是到了 while 语句，则 编译器代码跳出 分析 “定义” 的代码，进入 分析 &ldquo;语句&rdquo; 的代码。</p>

<p>注意一点即可，我上面举得例子。</p>

<p><strong>MyVisitor v ;
root = new Tree();</strong></p>

<p><strong>OK，返回了AST，好办了，可以直接 pretty print 出来了，因为你已经有了AST，即一棵树，所有这段程序的语义都存储起来了，你想怎么打印，不就怎么打印了？</strong></p>

<p>比如:</p>

<pre><code> @Override
  public void visit(ast.stm.If s)
  {
    this.sayln("");//if语句前换个行先
    this.printSpaces();
    this.say("if (");
    s.condition.accept(this);
    this.sayln(")");
    this.indent();
    s.thenn.accept(this);
    this.unIndent();
    this.printSpaces();
    this.sayln("else");
    this.indent();
    s.elsee.accept(this);
    this.unIndent();
    return;
  }
</code></pre>

<p><strong>note:
这里用的是访问者模式，这里不做讨论。</strong></p>

<p><strong>note:
so，对于paser，可以pretty print,由此可见，类似vim / emac 等编辑器，是怎么样智能的处理了？ 本人自己想的其中一种方法。
比如文件里有一段code，然后lexer + parser 之后生成了AST，然后修改AST，再把AST打印出来不就行了!!!!当然这个只是其中一种实现方式，
具体vim / emac 怎么实现的，我没看过源码，不知道，我只是给出了一种我自己的想法。</strong></p>

<p>parser，就是分析语法(你自己定义的语言的上下文无关文法)，然后返回一颗语法树，存储起来，然后传给elabrator。</p>

<p>关于parser，我应该说清楚了吧???</p>

<h4><strong>c. elaborator -> 其实就是语义分析，这里被称为  “精细化”  ，其实本质是 type checking，我平常就称之为类型检查。</strong></h4>

<p>工作职责:比如，看看类型，比如会不会出现类似 string = int + char ?  比如function call会不会调用参数个数是不是多一个，类型和声明的一不一样，否则报错，高级一点的elaborator，还会看看哪些变量，声明了，却没有用到，然后报出一个警告，等等。。。。。。。。。。。。。。</p>

<p>传统的语义分析方法：
Traditionally, semantics takes the form of natural language specification</p>

<p><strong>但是最新的论文，证明可以用数学的方法来完美解决这个技术:</strong>
But recent research has revealed that semantics can also be addressed via math, it&rsquo;s rigorous and clean</p>

<p><strong>这篇论文的题目是 -> Quick Introduction to Type Systems   -> type judging</strong></p>

<p>举个例子
 <img src="./261308377295779.png" alt="Alt text" /></p>

<p>上面是假设条件，hypothesis
类型系统是可以计算的， 比如 int + int -> 如果返回 int ，则 juding 正确
理论联系下实际:</p>

<p> 假设定义语义 : int + int -> int</p>

<pre><code>  @Override
  public void visit(ast.exp.Add e)
  {                       
      e.left.accept(this);

      if (!this.type.toString().equals("@int"))

           error("operator '+' left expression must be int type",e.addleftexplineNum);

      ast.type.T leftty = this.type;

      e.right.accept(this);

      if (!this.type.toString().equals("@int"))
         error("operator '+' right expression must be int type" ,e.addrightexplineNum);

      this.type = new ast.type.Int(); //表示当前操作 add，完成之后，“返回”一个操作数类型为 int

      return;

  }
</code></pre>

<p><strong>note:
这里不讨论关于继承(多态)，function call等再难一点的语义分析，不是本文重点。</strong></p>

<p>OK, elabrator 的工作，总结下，就是先扫一遍AST，然后生成相应的符号表(多态涉及prefix算法计算继承后的对象模型中虚函数表的函数指针排列顺序，这里不讨论)，然后进行类型系统的判断，报出一些语句出错的信息，或者警告信息。</p>

<p>elabrator我是否已经讲清楚了呢？</p>

<h4><strong>d. code generation -> 生成 IR</strong></h4>

<p>本人做了 minijava -> java bytecode / c / x86</p>

<p>minijava 直接 -> x86，我几次推翻重写，不过最后完成了，还是很 happy (minijava没有很高深的java语法，仅仅是封装，继承，多态，我用x86模拟了而已)</p>

<p>还是有一定难度的，用汇编这种低级语言去模拟封装，继承，多态，还是有一定难度的。</p>

<p>看过轮子哥专栏的朋友都知道，<a href="http://zhuanlan.zhihu.com/vczh-nichijou/19796639">http://zhuanlan.zhihu.com/vczh-nichijou/19796639</a>
轮子哥的理念我也是很推崇的，他其中写道&#8221;譬如说我大四尝试并最终成功的一个问题——怎么把C语言编译成x86&#8221;</p>

<p>其实我看到这里，我偷偷的小happy了一把，虽然我离轮子哥的水平还相差十万八千里，但是我觉得他还是识货的，他尽然提到这个东西。</p>

<p>1.不过他是大四完成的，而我是研一上半学期完成的。</p>

<p>2.不过他做的是c -> x86 ，我做的是minijava -> x86，当然他肯定不能包含全部c的语法，我当然也是。</p>

<p>3.直接把minijava->x86，我个人认为难度系数应该是c->x86的10倍。因为java是面向对象的语言。</p>

<p>至于我是怎么设计的，我还想专门开个专栏去解释我到底是怎么想的。</p>

<h4><strong>e. 讨论 exception,closure,SSA(static single assignment) 是怎么样实现的</strong></h4>

<p>exception:其实编译器通常有2种方法，</p>

<p><strong>1.基于异常栈
2.基于异常表：pay as you go</strong></p>

<p>细节，不想在本文讨论了。</p>

<p>closure: 我会讨论在java非要支持nested function之后，一步一步逃逸变量是怎么样不能够存储，然后引出closure的解决方法的，还会给出closure 和 object model 有什么区别？</p>

<p>SSA(static single assignment) 真心是一种牛逼的IR，让很多优化变得非常简单。但是内容太多，写不完了。自从有的这个SSA，gcc版本从某一个版本，忘了，开始全部把基于 CFG , DFG 的优化，变成SSA了</p>

<h4><strong>f.  讨论一下garbage collector</strong></h4>

<p>gc实际上要有很大的篇幅去讨论，基本上有这几种，我来数数：
<strong>1.基于引用计数的gc(浪费一个int大小要去存引用计数)
2.基于微软的 mark &amp; swap ，mark有个很trick的技巧
3.copy收集 ，我们lab做的，基于tiger book，13.3节
4.世代收集，关于代数，每代大小的阈值讨论，给予一个可靠的理论分析，本人喜欢用 平摊分析中的，基于动态表(其实就是c++的new)的方法
5.并发的gc</strong></p>

<p>还是需要花大篇幅去讨论，这里不说了。</p>

<h4><strong>g. optimization</strong></h4>

<p>优化太多了，真是说不完啊，暂时不想写了。对于优化容易出错，或者直接违反语义的，极端激进的死代码删除等等，老师说，有句名言叫做
1.请不要优化
2.实在想优化，请参考第1条
哈。</p>

<h4><strong>h. 关于我们学校课程最后的 final project 思考，关于 java 反射机制，gc的世代收集，翻译成 go / js ，jvm ，还有本人写的 minijava 直接 -> x86，我几次推翻重写，不过最后完成了，还是很 happy (minijava没有很高深的java语法，仅仅是封装，继承，多态，我用x86模拟了而已)</strong></h4>

<p>这个final project 实在是写不下，可能要花很长时间，才能把我是怎么想的写出来，先这样吧。。。</p>

<hr />

<h3><strong>5.用编译器知识理解语言小细节</strong></h3>

<h4>1.比如到底应该写成 char<em> p; 还应该写成 char </em>p; 这种问题其实很好理解，为什么，编译器怎么处理指针？ 即，碰到类型后面碰到<em>，就把后面的变量当做指针，好理解了吗，这就是为神马 char</em> p1,p2;  p2不是指针的原因</h4>

<p>我个人喜好，就把 char<em> 当做一个类型，只需要注意 char</em> p1,p2;  p2 这种情况即可，很多人不是喜欢这样写typedef char<em> pchar吗，这不就是赤裸裸的认为char</em>就是一个类型吗？没错，我就喜欢把它当做一个类型。</p>

<h4><strong>2.比如 const 修饰的 变量，总是分不清 ，</strong></h4>

<p> const char* p;</p>

<p> char const* p;</p>

<p> char* const p;</p>

<p> const char* const p;</p>

<p>我说一句话，你就能永远分清，信不信？当然这个是我从effective c++里面学的，</p>

<p>const 出现在*左边修饰的是指针指向的value，而出现在右边则是修饰的是指针，</p>

<p>没错，你已经会了。</p>

<p>前面2个一个意思，都是修饰value是const，第三个是修饰指针是const，第四个是2个都修饰。</p>

<h4><strong>3.比如神马 前加加，后加加 ，搞不清楚  ++a;a++;&hellip;.</strong></h4>

<p>int a = 1;</p>

<p>printf(&ldquo;%d&rdquo;,a++); 为毛答案还是1 ？</p>

<p>int a = 1;</p>

<p>printf(&ldquo;%d&rdquo;,++a); 为毛答案就是2了 ？</p>

<p>你如果学过编译器，你就懂了，你可以这样理解：</p>

<p>printf(&ldquo;%d&rdquo;,a++); 其实会被编译成2句话</p>

<p>printf(&ldquo;%d&rdquo;,a);</p>

<p>a++;(a = a + 1;)</p>

<p>这样，答案是神马，不用我说了吧。这个就叫做后加，懂了吧</p>

<p>printf(&ldquo;%d&rdquo;,++a);实际上也是会被编译成2句话</p>

<p>a++;(a = a + 1;)</p>

<p>printf(&ldquo;%d&rdquo;,a);</p>

<p>为什么是2？一目了然，以后还分不清前加后加吗？嘻嘻。</p>

<ol>
<li>其实 循环语句，其实对于x86来说就1种->跳转，当然跳转有2种，</li>
</ol>


<p>一是无条件跳转
L:
   jmp L;
二是有条件跳转
L：
  cmp eax,3
  jb L;
随便写的伪代码。</p>

<p>当然有的人问了，do while，while ，for 3种循环，你不是打自己脸吗？</p>

<p>我能说 其实翻译成 x86就是do while 吗，而 do while 不就是条件跳转吗？</p>

<p><strong>while 就是 do while，为什么？ 因为多一个入口检测而已
for 就是 do while + 入口检测 + update而已。具体神马的，自己去想吧。。。</strong></p>

<p>结语：</p>

<p><strong>note：
    其实编译器技术，还有很多很多，我只是讨论了其中的九牛一毛，而且由于篇幅限制，我写不下太多。作为第一篇文章，暂时先这样吧，以后再更新。</strong></p>

<pre><code>本人对信息安全也略懂，所以对底层的一些东西有一些自己的理解，其实这些都是基础，做安全最最重要的基础，是在课本上根本学不到的东西，最最精华的东西，在以后的文章中我会陆续提到：
</code></pre>

<p>学完编译器，对语言的理解又更深了一步，比如你看到如下东西,</p>

<pre><code>int c =  4;
int d;
void fun(int a,int b)
{   
    int n = 4;
    int i;
    for(i=0;i&lt;n;i++)
        printf("a+b=%d\n",a+b);
}

int main()
{
    fun(1,2);

    return 0;
}
</code></pre>

<hr />

<blockquote><p><strong>要思考，编译之后，生成怎么样的x86，calling convention，prolog/epilog，caller-saved/callee-saved</strong> <strong>register，堆栈平衡，所有变量的内存分布，函数符号修饰成什么样，静态链接，动态链接，地址修正，链接指示对编译过程的影响，如dllimport,dllexport,#pragma，函数声明等等</strong></p></blockquote>

<hr />

<p>以后的文章我会陆续解释。</p>

<h3><strong>其实学完编译器的真正效果，就是你看到上面的c，能想到，其实它就是神马。。。</strong></h3>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2015 - KIRAlzn -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->







		</div>
	</div>
</body>
</html>
