<h1>clean code</h1>

<hr />

<p>今天算是实习有10个月了，3个月在上海的intel中国总部，就是因为那里太闲了，闲是什么意思，我相信在bat上班的人，都不知道这个字是什么意思。。。在intel 5点钟准时下班，下了班和同学去健身房玩耍，到6点半再去外面吃个饭，然后再去附近玩玩，回到家在看看电影，玩玩游戏。。。感觉自己在养老。。不行，我刚走进社会，怎么能养老呢，我还要挣钱养家糊口呢，所以我果断辞职，来到北京百度。</p>

<p>我从intel走的时候，请大家吃散伙饭，小伙伴们有的说，让你去百度加班，保证你1个月就要哭着喊着回来，我说不会的，我就是喜欢加班，可不是吗，这都在百度呆了7个月了，不加班的天数好像可以用手指数出来。。。。</p>

<p>刚到intel的时候，人生第一次上班，竟然还在外企，挂着工牌的感觉，真的挺好的，而且环境也不错，不得不说，老外真的很会享受。。。</p>

<hr />

<p><strong>为什么要写这些呢，说实话，我最不后悔的就是在intel呆了3个月，为什么？说实话，那个时候闲，很闲，老大当然也很闲，所以我写的代码，老大都会从 代码整洁 + 代码逻辑，2个角度审查，简直把给我虐哭，然后才能svn。</strong></p>

<hr />

<p>由于写过编译器，深知寄存器分配算法(比如图着色)，所以我一般会考虑怎么样能写出最简洁，最干净，低内存，效率最高的代码，我喜欢python的简洁，我通常起个变量名or函数名都会斟酌一下，起个好点的名字，我喜欢我起的名字，能让别人一眼看过来就知道是什么变量类型，一眼就能看出这函数是在干什么，函数名起得得当，不多干一件事情，不少干一件事情。但是不要过度的把代码压缩到一行，把代码拆开写清楚，编译器会帮你优化的，放心吧。</p>

<p>我知道代码是写给人看的，如果这代码只有自己才看，那写的项目意义也不是很大。所以我在策略调研的时候写的代码，也是非常规范的，我写代码的时候也会考虑会不会有漏洞，比如缓冲区溢出，整形数溢出，格式化字符串攻击等等漏洞，毕竟以前搞信息安全比较多。</p>

<p>我喜欢我写的代码，看上去很舒服，风格一致，干净，整洁，每个函数都封装的恰到好处，都在同一抽象层级，函数的逻辑就像在讲故事一样，层层深入。</p>

<p>我喜欢我写的代码，能让别人有看下去的欲望，所以我交接给别人的模块，别人绝对不会在背后骂我。</p>

<hr />

<p>先说一下：</p>

<ol>
<li>我在intel的时候，带我的是以前是在ibm做架构师的，后来才到intel的，有很多年工作经验，虽然只教了我写了3个月代码，但是还是收获很多</li>
<li>我走的时候，老大推荐我看clean code，我后来看了一半，一直受用到现在</li>
<li>到百度之后，现在在web data部门，现在主要在做通用文本tag挖掘，机器学习策略相关，虽然以前我想做信息安全，但是可能没有机会，现在既然做这个方向，我就要好好做好，不能让我的部门人失望</li>
</ol>


<hr />

<p>先看一段反面教材,这段代码是一个t4哥写的。</p>

<hr />

<pre><code>qe_map = {}
qeid_map = {}
fh = open('./entity_link_res', 'r')
cont = fh.read()
lines = cont.split('\n')
for item in lines:
    arry = item.split('\t')
    if len(arry) != 5:
        continue
    k = arry[0]
    v = arry[2]
    eid = arry[3]

    if k in qe_map:
        qe_map[k].append(v)
    else:
        qe_map[k] = []
        qe_map[k].append(v)
    if k in qeid_map:
        qeid_map[k][v] = eid
    else:
        qeid_map[k] = {}
        qeid_map[k][v] = eid
fh.close()  


tks = my_wordrank.token_li
pst = my_wordrank.postag_li
wks = my_wordrank.wordrank_li
trk = my_wordrank.trunk_li
wdn = my_wordrank.wordner_li
</code></pre>

<hr />

<p>好，我来说一下，这段代码有多么让人崩溃。</p>

<p>1.首先entity_link_res是900个G，虽然是在hadoop上面跑的，幸好有分区，不然，你内存能一把读进去？一句一句读多好？省多少内存？</p>

<p>2.变量名字实在取得让人作呕。</p>

<p>(1)fh是个什么东西？ file handle吗，你要是想写简称，就要起个让大家耳熟能详的，比如你取个 fin，fout都是能忍的好吗</p>

<p>(2)for item in lines: 为什么不写 for line in lines: 呢？ item是个什么东西？能让人看出你是什么？你取名叫 line不是一目了然吗？ 或者你直接</p>

<p>fin = open(&ldquo;xx&rdquo;, &lsquo;r&rsquo;)</p>

<p>for line in fin:</p>

<p>这样不好吗？</p>

<p>(3)还有你这变量名起个 k v，干脆直接取名 int a，int b吧，好吗&hellip;最关键的是，你影响别人理解代码的速度，你这个字典，k是什么，v是什么，后面又字典套字典，你变量名不说清楚，你是什么，到后面，让人很难记住你的数据结构。</p>

<p>(4)最让我受不了的是，取名字，非要起简写，我后面会一再强调，代码是写给人看的，不是你一个人看的，你知道的简称，别人可能想个半天。</p>

<p>cont 是 content ，猜一猜能猜出来，但是还要花时间猜，这个还算好猜的，呵呵</p>

<p>arry 是 array，还真是会取名字啊，少写一个a，你觉得是在代码段少了编译了一点机器码是吗，这都进入符号表的东西，取长一点，让人一眼看出来不好吗，非要让人猜。。。</p>

<p>你这个 k 和 v 我就不想说啥了。</p>

<p>还有，你这个 tks 我能猜到是 tokens，你这个pst，我能猜到是 postags，你这个wks呵呵，其实是个weights，你这个trk是trunk，wdn是wordner。如果没用过nlpc的工具的同学，能知道你这名字取的是什么东西?能轻易猜出来？？</p>

<p>token_li 后面那个 _li 我到现在还不知道是什么意思，求大神告知，感激不尽。</p>

<p>还有你这个 eid，大家能猜到是 entity id吗？</p>

<p>qe_map = {}
qeid_map = {}</p>

<p>我觉得这两个字典的名字取得真是神来之笔。完全不知道什么意思。</p>

<p>3.语法不简洁。</p>

<pre><code>qe_map[k] = []
qe_map[k].append(v)
</code></pre>

<p>为什么不写成qe_map[k] = [v]</p>

<p>同理key不在的时候 qeid_map[k] = {k:v} 这样写不好吗</p>

<p>4.这段逻辑很搞笑吗</p>

<pre><code>    if k in qeid_map:
        qeid_map[k][v] = eid
    else:
        qeid_map[k] = {}
        qeid_map[k][v] = eid
</code></pre>

<p>简直哭了，k不在字典里面，你要新建一个词典，把v加进去，在字典里面，还是要把v加进去。。。</p>

<p>5.qe_map 这东西可是list，后面要in这个list判断在不在，可是遍历啊，哥。。。还有，这两个数据结构明显重复了啊，设计一个就行了。字典是O(1)查找啊，用list干啥用？</p>

<p>6.建议封装成函数，直接写在全局里面，我总觉得有一丝丝不妥</p>

<p>7.最后希望处理行后面要加个strip()，把两边多余的空格去掉 line = line.strip()</p>

<hr />

<p>为什么突然想写这篇blog了呢，是因为感觉百度对于代码整洁，好像做的不是很到位，以前提交svn的时候，都不需要经过code review，没有bug，测试通过后，就可以提交svn，然后部署上线。</p>

<p>但是，想一想维护起来，是不是很恶心呢？一个冗长的代码，里面竟是一些冗余的逻辑，变量名起的一团糟，函数名也是，让人看函数名，根本不知道函数在做什么，注释也有的和代码不一样，添加一个功能，需要改的地方那么多，所以每天填bug的速度可能==增加新bug的速度，如果让新人接手，说实话，烂代码，不如自己重写一个来的好。</p>

<p>不整洁的代码可能让一个项目彻底崩溃，所以一个整洁的代码真的很重要。</p>

<p><strong>铺垫了这么久，可以开始写clean code了。</strong></p>

<h2>由于本人写的代码，也不是很好，只是写下自己的理解，如果有不对的地方，欢迎批评指正。谢谢。</h2>

<hr />

<h3>关于信息安全</h3>

<hr />

<p>首先，一段代码，要考虑是用什么语言写的，这个语言的特性是什么，有没有可能造成安全的隐患。</p>

<p>如果你用c，c++语言写程序，光是代码整洁，是远远不够的，一个 strcpy，没有检查边界，就可能造成非常严重的后果，上次那个 openssl 里面的 &ldquo;Heartbleed&rdquo; 漏洞，其实很简单，就是 strcpy，没有检查边界，导致输入被恶意构造，然后多copy进去了，覆盖了上面的内存，比如被截获了返回地址，然后跳转到你设计的函数代码那里，干一些非法勾当。。。然后再jump回来。。神不知鬼不觉。。</p>

<p>还有整形数溢出。现在算法导论里面，关于二分查找的实例代码，还是有这个漏洞，一个整形数int，32位，2<sup>31</sup>如果溢出，就会变成负数，</p>

<p><code>void function(unsigned param) {if (param &lt; maxLength) then}</code></p>

<p>可以看出，为了让 param 在正数范围能使用的更大一些，你用了unsigned，看似很聪明的举动，其实。。。如果你传一个 -1 给 param，会发生上面后果。。 -1就是 0xffff ffff，你让这个parm当做无符号去处理，结果变成最大的正数。。。param 一定是 大于 maxLength 了。。。 但是其实你传的 -1 ，-1 肯定比 maxLength这个正数要小的啊，这是你想要的结果吗？</p>

<p>格式化字符串攻击，堆溢出，堆喷射等等安全知识，我就不说了，只是举个例子，说明一下，对于c，c++程序员的要求是非常高的，需要知道这些信息安全的知识，而且没有garbage collector，需要自己手动释放内存，处理的不好很容易内存溢出。</p>

<hr />

<h3>汇编</h3>

<p>对于汇编来说，当年老外为什么要发明c语言，我以前已经说过了，是因为老外不想写汇编了，一句一句的操作寄存器，真的很头疼，而且很容易出错，不如就把汇编浅封装一下，变成了c语言，这样既保证了c拥有最高的效率，又少写几条汇编了。最最最关键的是，c的编译器非常好写，因为，就是汇编的浅封装嘛~</p>

<h3>c</h3>

<p>以前的内存很小，cpu运行速度不是很快，而且只有汇编语言的时候，老外写一个os kernel知道怎么写的吗？每一个字节的存储单元是什么，他们都非常清楚，不得不说当年写xv6的作者，真是天才，我们学习这个os kernel的时候花费了多大力气。。呵呵，当年保健哥问，这8000多行的os，一行都不能删，恰到好处，问同学，有能删的地方吗？有个人说，注释！！！！！哈哈，不过确实有2行代码能删，就是初始化为0的两个变量，那里，因为这两个变量是全局变量而且未初始化，所以编译之后放到bss段，而bss段会自动清0，所以不用手动在初始化为0了。扯远了。</p>

<p>总之，c的出现，就是完全的汇编浅封装，所以里面的库函数也不会检查什么边界条件之类的，有的时候，很trick的做法就是故意溢出一点内存，然后标识等等。</p>

<p>但是这些都是建立在每个人都是好人的情况下。。。就像tcp/ip协议一样，里面设计的很多协议，第一版本就是没有考虑过安全问题，万一被人攻击怎么办？？？</p>

<h3>c++</h3>

<p>说起c++，还是有很多情愫在里面。</p>

<ol>
<li>不要把c的坑，都归结到c++里面，c++如果当年不是为了兼容c，编译器设计的就不会那么复杂了。当然如果不兼容c，人们也不一定会用了吧，毕竟c++的学习成本太高了。</li>
<li>我之前写过，这里不再赘述的举例子。</li>
</ol>


<p>我总结一下：</p>

<p>(1) c++用 namespace ，模板，函数重载，函数形参默认值解决了c中函数变量很ugly的问题，比如相关功能，来个fun1，fun2之类的</p>

<p>(2) c++用const，enum，inline解决了c中宏的各种坑，比如你调试的时候，对于宏，你在调试器里面发现的仅仅是一个数字，因为宏在预处理阶段已经被替换，变量名是不进入符号表的，所以对于一个2232，你调试的时候根本不知道这是什么。而c++对于inline的支持，我之前写的很详细。</p>

<p>(3) c++引入const，让很多东西不能改变，这样有助于权限的问题，传参的时候形参函数指针设置为const，意味着，在函数体里面，是不能通过指针修改这个变量的，或者，const变量只能调用const成员函数等等。</p>

<p>(4) 封装，继承，多态，能让c++更oo，好处就不说了。</p>

<p>(5) c++将c中强制类型转换给拆成4个，拆分的越细，越不容易出错</p>

<p>(6) RTTI让c++提升了一个编程高度</p>

<p>(7) 智能指针auto_ptr, shared_ptr让c++更能灵活处理内存，防止内存泄露</p>

<p>(8) c++异常比c做的好，但是java更好。。</p>

<p>(9) stl模板库是非常大的贡献，boost，tr1等等，但是如果编译不通过，stl里面全是模板，迭代器，调试错误你根本看不懂。。</p>

<h3>java</h3>

<p>(1) java彻底废了指针，不让你用指针，用引用，其实引用就是用指针实现的，但是就是不让你用而已，java不仅有object model，还有reflection model，gc model，还有closure model等等，这些 memory model都在内存中，都能用指针去访问，那还有什么安全性可言？？所以java彻底废掉，让你引用，不能去给这个指针加减运算</p>

<p>(2) 我觉得gc绝对是编程语言史上伟大发明之一，真的，我们学tiger book的时候学了5种gc，我在编译器里面实现了tiger book 13.3节的copy collection我来稍微总结一下</p>

<p>a) 基于引用计数的gc：优点就是方便实现，缺点很明显，一是浪费4个字节去存引用计数，而是会造成环状引用死锁，每个都是1，死链</p>

<p>b) 基于微软mark&amp;swap：故名思议，标记&amp;清扫，人们发现，引用计数，为什么要花4个字节去存储呢，被引用1次，和被引用1000次都是不能被回收，所以用1个bit去标记就ok了啊，现在一般的oo对象都是对齐到4个字节，所以地址的最后两位是0，所以这两位可以用一位，在c的red black tree实现里面，还有一个bit用来存放是节点是 红色 or 黑色。这样所有的对象，连成一张图，遍历一遍图就知道，被mark过的就是还在被引用的，不能被回收，其余回收。</p>

<p>c) copy收集：我们当时用的算法叫Gimple，就是 a simple garbage collector，一遍是from，一遍是to，互换的，算法我总结了，这里写不下。</p>

<p>d) 世代收集：copy收集的拓展，是有一篇论文说，发现新生代的对象一般容易死掉，所以先在小的内存区域迭代几轮，还没死的对象，移到高层，反复这样移动，迭代这个过程。算法比较好，一般都用世代收集</p>

<p>e) 并发的gc：我们中科大&amp;yale高可信实验室，就是在用形式化方法去证明一个并发的gc木有bug，如果gc都可以并发了，那在服务器上部署之后，得提升多大的效率？？所以，我们老板，郭宇，还是很吊的，形式化方法第一人。</p>

<p>(3) java废掉c++中一些比较恶心的东西，比如 function object，这东西一般人还真不知道，还有类似 运算符重载等等东西，因为根本没什么人用，留着干啥，那语法那么复杂。。</p>

<p>(4) java废掉c++多重继承，引入接口多重继承坑非常大，做编译器的时候有人说要扩展支持多重继承，我就问他，呵呵，怎么解决菱形多重继承中数据二义性问题，微软用虚基函数表解决，请问你用什么方法？？哈哈，当年rbb就被我问了，对不起啊,谁让你final project里面要支持多重继承呢。</p>

<p>(5) java对异常的支持比c++强很多，java改进了c++比如 构造函数，copy构造函数，析构函数等等。</p>

<p>(6) java用虚拟机技术，真正解决跨平台问题</p>

<p>(7) java有反射等高级一点的用法，我当年在intel的时候用c#的反射，做了一个还不错的项目</p>

<p>(8) java的类库确实要比c,c++要强一点</p>

<h3>关于语言的总结就想到这么多，以后再补充，这是以前承诺需要总结的，先写上</h3>

<hr />

<h2>ok,扯了这么多，可以开始写clean code了</h2>

<hr />

<p><strong>首先，糟糕的代码维护性太差，增加新功能更恶心，引进新功能，修改bug的速度==引进新bug的速度。</strong></p>

<p><strong>所以糟糕的代码，可能毁掉整个项目，甚至可能毁掉整个公司。</strong></p>

<p><strong>我就不举例子了。</strong></p>

<p><strong>其实clean code里面说了一个很有意思的事情，如果用编辑器回放功能，查看自己写代码1个小时的过程，会发现，</strong>
<strong>其实大部分时间，我们都在滚动屏幕，看以前写的代码，思考，真正在写的时间，其实不多。</strong></p>

<p><strong>所以之前写的代码就非常整洁，对以后的代码是不是更有帮助呢？</strong></p>

<hr />

<h2>1.有意义的命名</h2>

<hr />

<p>对于变量名来说，对于稍微大一点的程序来说，不要起什么int a，int b之类的名字，因为，这样的名字，可能只有你知道这个是什么意思，而且可能刚过了一个月，连你自己也不记得那个变量是干什么的了，所以等你下次去看这个段代码or别人去看你的代码的时候，是不是会浪费很多时间呢，而且别人如果看不懂，鄙视你的概率也很高吧~~~多少接手你代码的人骂过你，写的什么烂代码~~~~</p>

<hr />

<p><strong>ps</strong>：其实匈牙利命名法，对于c，c++还是有一定用处的，真的，虽然很多正式工都认为，包括我以前intel老大都认为匈牙利命名法其实是没有道理的，但是我觉得还是有一定的道理的。
因为在c，c++中，主要就是用指针操作的，你需要知道这个变量是否是指针，然后用 *pArray 去访问，如果一个变量前面是 p打头，一眼就能看到这是指针，而如果是一个 int fun(int arr)这样的函数签名，传进来的是pass by value，你是不能修改调用方传进来的那个值的，但是如果是个指针就能通过访存去改变，这是很重要的，c就是玩内存嘛</p>

<hr />

<p>(1) 最好别用 int a ,int b这种命名方式 比如</p>

<p>int elapsedTimeInDays;</p>

<p>int daysSinceCreation;</p>

<p>这些都是很好的命名，一眼就能看出你这个变量的意思是什么。</p>

<p>(2) 不要害怕长的名字，长的名字，并不意味着差，而是更能表达清楚变量的含义，我写过编译器，我负责的告诉你，长名字不占代码段，只是在编译，链接的时候占用一下符号表而已</p>

<p>(3) 变量我喜欢用驼峰式这种命名，而区别于函数名，我函数名都是大写，但是有些人喜欢用 _ 去连接，我觉得也行，只是我觉得_ 用多了，显得不是很美观，适当的用一下也是可以的，比如 u_tag，表示 这个tag被解码成unicode,其实比
utag要好看一点，比如有的时候 TFIDF这种，全是大写，不容易区分的时候，可以加上 TF_IDF 这样区分，也是不错的选择</p>

<p>(4) 尤其是在python里面，数据结构用的很多，比如 list， dict，tuple，set等等，名字取的好看，可以一眼认出你是什么数据结构，比如 mapDict 是不是比普通的名字要强呢，或者你喜欢匈牙利命名法，你可以 dict_map，也是可以的，不过我更喜欢 mapDict ,accountList</p>

<p>(5) 避免误导，不要你的数据结构是dict，你却取个list的名字，这样很容易误导，比如 mapList, 其实你是个字典类型。。。。</p>

<p>(6) 变量名不要取的太相似，要有区分度</p>

<p>GetActiveAccount()</p>

<p>GetActiveAccounts()</p>

<p>GetActiveAccountInfo()</p>

<p>鬼知道这三个函数有什么区别，该调用哪一个呢？</p>

<p>(7) 最好不要写简写，因为不是每个读你代码的人，都知道那个简称，比如我见过c#工程里面有人这样写，btnExit，其实也没什么，btn是button的简写，因为大部分都知道这个简写，所以问题不大，但是如果碰到 tksXXX，前面你知道tks是啥，可能是个tokens，或者是什么，什么，(2)中我总结了，不要害怕长名字， tokensXXX，绝对比tkXXX强</p>

<p>(8) 避免将同一个单词用于不同含义，否则很容易造成歧义</p>

<p>(9) 比如写ml算法的时候，尽量去用通用教材里面的专业符号，变量，这样不容易引起歧义，要知道，看你这段代码的，大部分都是会这个ml算法的人，而每个学校可能用的教材不一样。</p>

<hr />

<h2>2.函数</h2>

<hr />

<p>(1) 首先，单一职责原则，函数只做一件事情，不代表函数里面只有一句话，而是说，这个函数里面，只做同一层级的抽象，而更第一层次的抽象，就应该放到下一个函数里面</p>

<p>clean code的作者说，他写过很多函数，有几千行的，几百行的，几十行的，几行的，经验说告诉他函数就该小，这句话是没错的。</p>

<p>函数小，意味着更能只专注一件事情。</p>

<p>为什么要写小函数呢？？</p>

<p>因为可维护性强啊，你一个函数只做一件事情，改这个事情的时候，就改你这一处代码不就ok了，调用你的地方基本不用动了</p>

<p><strong>同一层级的抽象，这个很重要，不是意味着，你一个函数就只能写一行代码。</strong></p>

<pre><code>def ComputeTFIDF():

    ComputeTF()

    ComputeIDF()

    return xxx.
</code></pre>

<p>同一个层级的抽象，都可以放到同一个函数里面。</p>

<p>(2) 函数的参数，一般是一个or2个，最好不要超过3个</p>

<p>ps: 当年设计fast calling convention的时候，ecx，edx作为快速调用的参数，所以可见，大部分函数，都是小于2个参数的</p>

<p>为什么？</p>

<p>a) 因为一个是单元测试的时候，会有麻烦，你想想，要考虑全部边界，而考虑全部边界，3个参数以上，需要多少种组合方式呢。。。</p>

<p>b) 而参数越多，也在一定程度上说明，函数可能干的事情不是很多，所以违反了 单一职责原则。</p>

<p>(3) 函数名取的要恰当,不要偷偷的多干了某件事情，或者偷偷的少干了几件事情。比如</p>

<pre><code>public boolean checkPassword() {

    ...
    session.initialize()
    ...

}
</code></pre>

<p>这个函数名字，并没说这个函数里面会对session做初始化，后面如果又初始化了一次，不就错了吗。</p>

<p>所以把函数名改成。 checkPasswordAndInitializeSession 会更好一点。</p>

<p>(4) 分清 指令级别 还是 询问级别，这点其实很重要，对于代码清晰度的角度来说，很重要。</p>

<pre><code>if (set("username", "unclebob"))
    ...
</code></pre>

<p>到底是set，还是询问，因为是放在if的condition条件里面的</p>

<p>不如改成</p>

<pre><code>if(attributeExists("username"))
    setAttribute("unclebob")
    ...
</code></pre>

<p>(5) 函数重复部分拉出来，作为函数，这就是重构，不要冗余代码。</p>

<p>(6) 函数名字应该取得具有描述性，有意义，这点上面已经反复强调过了。</p>

<hr />

<p>ps: 其实函数小，意味着你要频繁的调用，而csapp里面学的，函数调用其实需要10个左右cpu时钟周期，其实也不小，要不然为什么要有inline函数的出现呢？？？这其实是一个权衡的问题。</p>

<hr />

<h2>3.注释</h2>

<hr />

<p><strong>理论上说，或者平时吹牛逼的时候，都说，其实，没有注释的程序其实才是最好的，如果程序从命名的角度，</strong>
<strong>代码清晰的角度，已经足够表达含义了，那么也就不需要注释了。</strong></p>

<hr />

<p>(1) 当你的函数代码，功能升级的时候，或者修改了一点的时候，或者修正了一个bug的时候，你能保证，你的函数注释，一定会随着修改吗？事实证明，做到这个很难。</p>

<p>所以，函数注释一定是honest的吗？只有写在那里的代码，才不会骗你。</p>

<p>(2) 如果你的函数名取的够好，而且单一职责，比如说 bool CheckPassword(),正常人肯定立马就知道这是什么意思，还需要你加段冗余的注释，说'check the password if right return true,else return false'，所以说，一般好的函数名字说明了这个函数在干啥，不用多此一举的写注释把。当然有特例，下面再说。</p>

<p>(3) 用代码阐释，不要用注释,eg.</p>

<pre><code>if ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; employee.age &gt; 65 )
</code></pre>

<p>大部分人看到这里，就会问，这么trick的判断，到底是啥，一般人会写个注释，说怎么怎么样trick</p>

<p>其实可以这样，用代码说话，封装一层</p>

<pre><code>if (employee.isEligibleForFullBenefits())
</code></pre>

<p>是不是清晰很多？？而且隐藏了判断的trick细节，使得函数体里面处于同一抽象层级。</p>

<hr />

<h3>好注释</h3>

<hr />

<p>(1) 比如说开头的copyright 信息，法律相关的</p>

<p>(2) 对某些特殊意图的阐释，比如某些地方为什么要那么trick等等。</p>

<p>(3) 警示作用，可以阻止以后的程序员干某种傻事</p>

<p>(4) todo注释，还是可以留的</p>

<p>(5) 描述性注释，比如某个很trick的算法注释，可以省去程序员阅读算法内容，可以直接使用</p>

<hr />

<h3>坏注释</h3>

<hr />

<p>(1) 冗余的注释，就是刚才说的 bool CheckPassword()，正常人都知道你在干什么，而且函数的名字已经表达了意图，何必多此一举呢。</p>

<p>(2) 不够精确的注释，如果函数注释，不能准确反映函数代码的情况，就不要写了，否则还会误导，多干一件事情，少干一件事情啥的，前面说过了，很坑。</p>

<p>(3) 废话注释,比如</p>

<p>a) 一个构造函数前面加上一段注释 /* default constuctor  */是不是显得多余了？</p>

<p>b)</p>

<p>/* the name */</p>

<p>private String name;</p>

<p>是不是显得很多余了？？有啥用？？</p>

<p>(4) 归属名注释， 版本控制器精确的写了，谁谁谁，在某个时刻，写了check in了某些代码，不用加上类似这样的注释吧</p>

<p>/* add by kira */</p>

<hr />

<h1>不行了，写不动了。以后再更新</h1>

<hr />

<h2>最后说下</h2>

<hr />

<p>语言，真的只是一种工具，我写过编译器，我知道，而你要在公司里面解决的是问题，要面向问题出发，解决这个问题，最快的是用什么算法，什么语言，多快能解决。</p>

<p>打个不恰当的比方，从最基本的说起</p>

<ol>
<li><p>现在只有1000个数需要排序，反正手动排序是不可能了，你需要写一个排序算法去解决，那你是写一个O(n)的算法，计数排序，基数排序，并发的 devide and conquer？ 还是用一些非常好写的 O(nlogn)的算法？还是用更好写的O(n<sup>2</sup>)算法去写? 干脆不用写，直接调用库函数，直接sorted一下，只要写一行代码？</p></li>
<li><p>你现在要处理一段文本，是写个shell几行搞定，还是写个python？</p></li>
<li><p>。。。</p></li>
</ol>


<p>代码只是工具，需要结合实际问题，选用合适的工具，去解决问题。</p>

<p>ps: 上次有个任务是计算TF-IDF的，我之前写的代码，根本跑不通300w行的数据，一晚上没跑出来，后来用了倒排索引算法，性能飙升</p>

<p>GetDocumentDict,cost: 8s</p>

<p>ComputeTFdict,cost: 7s</p>

<p>CreateInvertedIndex,cost: 2s</p>

<p>ComputeTFIDFDict,cost: 8s</p>

<p>RankTFIDFDict,cost: 20s</p>

<p>WriteDictIntoFile,cost: 381s</p>

<p>看前面，之前跑一晚上跑不通的数据，其实在内存中计算完成，只需要45秒，所以说算法真的很重要</p>

<p>然后我拿这个程序去跑4000w行的数据，又歇菜了。哈哈</p>

<p>赶紧改成 map reduce ，去hadoop上面跑吧~~~~~</p>

<hr />

<h2>最后，还是用一段原创程序，送给 爱我的人 和 我爱的人 ~~~</h2>

<hr />

<pre><code>void main() {
    int i = 0x00752065;
    int j = 0x00766f6c;
    short k = 0x0049;

    printf("%s %s%s",&amp;k,&amp;j,&amp;i);
}
</code></pre>
